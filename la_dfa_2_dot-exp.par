%start LaDfa2Dot
%title "LaDfa2Dot grammar"
%comment "Create a Graphviz representation of `parol`'s LookaheadDFAs"
%line_comment "//"
%block_comment "/\*" "\*/"

%%

/*  0 */ LaDfa2Dot: LaDfa2DotList /* Vec */;
/*  1 */ LaDfa2DotList /* `Vec<T>::Push` */: AttributeOpt^ /* Clipped */ Item LaDfa2DotList;
/*  2 */ LaDfa2DotList /* `Vec<T>::New` */: ;
/*  3 */ AttributeOpt: AttributeOpt0 /* Option */;
/*  4 */ AttributeOpt0 /* `Option<T>::Some` */: Hash LBracket Ident AttributeArgOpt RBracket;
/*  5 */ AttributeOpt0 /* `Option<T>::None` */: ;
/*  6 */ AttributeArgOpt: LParen Ident RParen;
/*  7 */ Item: UseStatement^ /* Clipped */;
/*  8 */ Item: ConstDeclaration;
/*  9 */ UseStatement: 'use' ScopedQualifiedIdent Semicolon;
/* 10 */ QualifiedIdent: Ident QualifiedIdentList /* Vec */;
/* 11 */ QualifiedIdentList /* `Vec<T>::Push` */: DoubleColon Ident QualifiedIdentList;
/* 12 */ QualifiedIdentList /* `Vec<T>::New` */: ;
/* 13 */ ScopedQualifiedIdent: QualifiedIdent ScopedQualifiedIdentOpt /* Option */;
/* 14 */ ScopedQualifiedIdentOpt /* `Option<T>::Some` */: DoubleColon ScopedList;
/* 15 */ ScopedQualifiedIdentOpt /* `Option<T>::None` */: ;
/* 16 */ ScopedList: LBrace ScopedListItems CommaOpt RBrace;
/* 17 */ ScopedListItems: ScopedQualifiedIdent ScopedListItemsList /* Vec */;
/* 18 */ ScopedListItemsList /* `Vec<T>::Push` */: Comma^ /* Clipped */ ScopedQualifiedIdent ScopedListItemsList;
/* 19 */ ScopedListItemsList /* `Vec<T>::New` */: ;
/* 20 */ ConstDeclaration: ConstPreamble ConstDeclarationSuffix;
/* 21 */ ConstDeclarationSuffix: TypeSpec Assign ConstVal Semicolon;
/* 22 */ ConstDeclarationSuffix: Skip;
/* 23 */ ConstPreamble: ConstQualifier ConstName Colon;
/* 24 */ ConstQualifier: ConstQualifierOpt /* Option */ 'const';
/* 25 */ ConstQualifier: 'static';
/* 26 */ ConstQualifierOpt /* `Option<T>::Some` */: 'pub';
/* 27 */ ConstQualifierOpt /* `Option<T>::None` */: ;
/* 28 */ ConstName: Ident;
/* 29 */ ConstVal: Number;
/* 30 */ ConstVal: String;
/* 31 */ ConstVal: QualifiedVal;
/* 32 */ ConstVal: ArrayVal;
/* 33 */ ConstVal: TupleVal;
/* 34 */ ArrayVal: Amb LBracket ArrayValOpt /* Option */ CommaOpt RBracket;
/* 35 */ ArrayValOpt /* `Option<T>::Some` */: ConstValList;
/* 36 */ ArrayValOpt /* `Option<T>::None` */: ;
/* 37 */ ConstValList: ConstVal ConstValListList /* Vec */;
/* 38 */ ConstValListList /* `Vec<T>::Push` */: Comma ConstVal ConstValListList;
/* 39 */ ConstValListList /* `Vec<T>::New` */: ;
/* 40 */ TupleVal: LParen TupleValOpt /* Option */ CommaOpt RParen;
/* 41 */ TupleValOpt /* `Option<T>::Some` */: TupleValues;
/* 42 */ TupleValOpt /* `Option<T>::None` */: ;
/* 43 */ TupleValues: ConstVal TupleValuesList /* Vec */;
/* 44 */ TupleValuesList /* `Vec<T>::Push` */: Comma ConstVal TupleValuesList;
/* 45 */ TupleValuesList /* `Vec<T>::New` */: ;
/* 46 */ QualifiedVal: QualifiedIdent QualifiedValOpt /* Option */;
/* 47 */ QualifiedValOpt /* `Option<T>::Some` */: QualifiedValOptGroup;
/* 48 */ QualifiedValOptGroup: StructVal;
/* 49 */ QualifiedValOptGroup: TupleStructVal;
/* 50 */ QualifiedValOpt /* `Option<T>::None` */: ;
/* 51 */ StructVal: LBrace StructValOpt /* Option */ RBrace;
/* 52 */ StructValOpt /* `Option<T>::Some` */: MemberValues;
/* 53 */ StructValOpt /* `Option<T>::None` */: ;
/* 54 */ MemberValues: MemberValue MemberValuesList /* Vec */ CommaOpt;
/* 55 */ MemberValuesList /* `Vec<T>::Push` */: Comma MemberValue MemberValuesList;
/* 56 */ MemberValuesList /* `Vec<T>::New` */: ;
/* 57 */ MemberValue: Ident Colon ConstVal;
/* 58 */ TupleStructVal: TupleVal;
/* 59 */ TypeSpec: QualifiedIdent;
/* 60 */ TypeSpec: ArrayType;
/* 61 */ TypeSpec: TupleType;
/* 62 */ ArrayType: Amb LBracket ArrayTypeSpec RBracket;
/* 63 */ ArrayTypeSpec: ArrayTypeSpecOpt /* Option */ Ident Semicolon Number;
/* 64 */ ArrayTypeSpecOpt /* `Option<T>::Some` */: Amb;
/* 65 */ ArrayTypeSpecOpt /* `Option<T>::None` */: ;
/* 66 */ TupleType: LParen TupleItems CommaOpt RParen;
/* 67 */ TupleItems: TypeSpec TupleItemsList /* Vec */;
/* 68 */ TupleItemsList /* `Vec<T>::Push` */: Comma TypeSpec TupleItemsList;
/* 69 */ TupleItemsList /* `Vec<T>::New` */: ;
/* 70 */ Skip: /(?s)Lazy<Vec<.*(?-s)/;
/* 71 */ CommaOpt: CommaOpt0 /* Option */;
/* 72 */ CommaOpt0 /* `Option<T>::Some` */: Comma;
/* 73 */ CommaOpt0 /* `Option<T>::None` */: ;
/* 74 */ Assign: '=';
/* 75 */ Number: /-?\d+/;
/* 76 */ Amb: '&';
/* 77 */ Semicolon: ';';
/* 78 */ Comma: ',';
/* 79 */ String: /(r#*)?"(\\.|[^\\])*?"#*/;
/* 80 */ Ident: /[a-zA-Z_][a-zA-Z0-9_]*/;
/* 81 */ DoubleColon: '::';
/* 82 */ Colon: ':';
/* 83 */ LBrace: '{';
/* 84 */ RBrace: '}';
/* 85 */ LBracket: '[';
/* 86 */ RBracket: ']';
/* 87 */ LParen: '(';
/* 88 */ RParen: ')';
/* 89 */ Hash: /#/;
