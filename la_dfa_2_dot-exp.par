%start LaDfa2Dot
%title "LaDfa2Dot grammar"
%comment "Create a Graphviz representation of `parol`'s LookaheadDFAs"
%line_comment "//"
%block_comment "/\*" "\*/"

%%

/*  0 */ LaDfa2Dot: LaDfa2DotList /* Vec */;
/*  1 */ LaDfa2DotList /* `Vec<T>::Push` */: AttributeOpt^ /* Clipped */ Item LaDfa2DotList;
/*  2 */ LaDfa2DotList /* `Vec<T>::New` */: ;
/*  3 */ AttributeOpt: AttributeOpt0 /* Option */;
/*  4 */ AttributeOpt0 /* `Option<T>::Some` */: Hash LBracket Ident AttributeArgOpt RBracket;
/*  5 */ AttributeOpt0 /* `Option<T>::None` */: ;
/*  6 */ AttributeArgOpt: AttributeArgOpt0 /* Option */;
/*  7 */ AttributeArgOpt0 /* `Option<T>::Some` */: LParen Ident RParen;
/*  8 */ AttributeArgOpt0 /* `Option<T>::None` */: ;
/*  9 */ Item: UseStatement^ /* Clipped */;
/* 10 */ Item: ConstDeclaration;
/* 11 */ UseStatement: 'use' ScopedQualifiedIdent Semicolon;
/* 12 */ QualifiedIdent: Ident QualifiedIdentList /* Vec */;
/* 13 */ QualifiedIdentList /* `Vec<T>::Push` */: DoubleColon Ident QualifiedIdentList;
/* 14 */ QualifiedIdentList /* `Vec<T>::New` */: ;
/* 15 */ ScopedQualifiedIdent: QualifiedIdent ScopedQualifiedIdentOpt /* Option */;
/* 16 */ ScopedQualifiedIdentOpt /* `Option<T>::Some` */: DoubleColon ScopedList;
/* 17 */ ScopedQualifiedIdentOpt /* `Option<T>::None` */: ;
/* 18 */ ScopedList: LBrace ScopedListItems CommaOpt RBrace;
/* 19 */ ScopedListItems: ScopedQualifiedIdent ScopedListItemsList /* Vec */;
/* 20 */ ScopedListItemsList /* `Vec<T>::Push` */: Comma^ /* Clipped */ ScopedQualifiedIdent ScopedListItemsList;
/* 21 */ ScopedListItemsList /* `Vec<T>::New` */: ;
/* 22 */ ConstDeclaration: ConstPreamble TypeSpec^ /* Clipped */ Assign^ /* Clipped */ ConstVal Semicolon^ /* Clipped */;
/* 23 */ ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;
/* 24 */ ConstPreamble: ConstQualifier^ /* Clipped */ ConstName Colon^ /* Clipped */;
/* 25 */ ConstQualifier: ConstQualifierOpt /* Option */ 'const';
/* 26 */ ConstQualifier: 'static';
/* 27 */ ConstQualifierOpt /* `Option<T>::Some` */: 'pub';
/* 28 */ ConstQualifierOpt /* `Option<T>::None` */: ;
/* 29 */ ConstName: Ident;
/* 30 */ ConstVal: Number;
/* 31 */ ConstVal: String;
/* 32 */ ConstVal: QualifiedVal;
/* 33 */ ConstVal: ArrayVal;
/* 34 */ ConstVal: TupleVal;
/* 35 */ ArrayVal: Ref^ /* Clipped */ LBracket^ /* Clipped */ ArrayValOpt /* Option */ RBracket^ /* Clipped */;
/* 36 */ ArrayValOpt /* `Option<T>::Some` */: ConstValList CommaOpt^ /* Clipped */;
/* 37 */ ArrayValOpt /* `Option<T>::None` */: ;
/* 38 */ ConstValList: ConstVal ConstValListList /* Vec */;
/* 39 */ ConstValListList /* `Vec<T>::Push` */: Comma^ /* Clipped */ ConstVal ConstValListList;
/* 40 */ ConstValListList /* `Vec<T>::New` */: ;
/* 41 */ TupleVal: LParen^ /* Clipped */ TupleValOpt /* Option */ RParen^ /* Clipped */;
/* 42 */ TupleValOpt /* `Option<T>::Some` */: ConstValList CommaOpt^ /* Clipped */;
/* 43 */ TupleValOpt /* `Option<T>::None` */: ;
/* 44 */ QualifiedVal: QualifiedIdent QualifiedValOpt /* Option */;
/* 45 */ QualifiedValOpt /* `Option<T>::Some` */: StructOrTupleVal;
/* 46 */ QualifiedValOpt /* `Option<T>::None` */: ;
/* 47 */ StructOrTupleVal: StructVal;
/* 48 */ StructOrTupleVal: TupleStructVal;
/* 49 */ StructVal: LBrace^ /* Clipped */ StructValOpt /* Option */ RBrace^ /* Clipped */;
/* 50 */ StructValOpt /* `Option<T>::Some` */: MemberValues Comma^ /* Clipped */;
/* 51 */ StructValOpt /* `Option<T>::None` */: ;
/* 52 */ MemberValues: MemberValue MemberValuesList /* Vec */;
/* 53 */ MemberValuesList /* `Vec<T>::Push` */: Comma^ /* Clipped */ MemberValue MemberValuesList;
/* 54 */ MemberValuesList /* `Vec<T>::New` */: ;
/* 55 */ MemberValue: Ident Colon ConstVal;
/* 56 */ TupleStructVal: TupleVal;
/* 57 */ TypeSpec: QualifiedIdent;
/* 58 */ TypeSpec: ArrayType;
/* 59 */ TypeSpec: TupleType;
/* 60 */ ArrayType: Ref LBracket ArrayTypeSpec RBracket;
/* 61 */ ArrayTypeSpec: ArrayTypeSpecOpt /* Option */ Ident Semicolon Number;
/* 62 */ ArrayTypeSpecOpt /* `Option<T>::Some` */: Ref;
/* 63 */ ArrayTypeSpecOpt /* `Option<T>::None` */: ;
/* 64 */ TupleType: LParen TupleItems CommaOpt RParen;
/* 65 */ TupleItems: TypeSpec TupleItemsList /* Vec */;
/* 66 */ TupleItemsList /* `Vec<T>::Push` */: Comma TypeSpec TupleItemsList;
/* 67 */ TupleItemsList /* `Vec<T>::New` */: ;
/* 68 */ Skip: /(?s)&\[Production; \d+\] = &\[.*(?-s)/;
/* 69 */ CommaOpt: CommaOpt0 /* Option */;
/* 70 */ CommaOpt0 /* `Option<T>::Some` */: Comma;
/* 71 */ CommaOpt0 /* `Option<T>::None` */: ;
/* 72 */ Assign: '=';
/* 73 */ Number: /-?\d+/;
/* 74 */ Ref: '&';
/* 75 */ Semicolon: ';';
/* 76 */ Comma: ',';
/* 77 */ String: /(r#*)?"(\\.|[^\\])*?"#*/;
/* 78 */ Ident: /[a-zA-Z_][a-zA-Z0-9_]*/;
/* 79 */ DoubleColon: '::';
/* 80 */ Colon: ':';
/* 81 */ LBrace: '{';
/* 82 */ RBrace: '}';
/* 83 */ LBracket: '[';
/* 84 */ RBracket: ']';
/* 85 */ LParen: '(';
/* 86 */ RParen: ')';
/* 87 */ Hash: /#/;
