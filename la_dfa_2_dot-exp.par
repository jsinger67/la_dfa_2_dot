%start LaDfa2Dot
%title "LaDfa2Dot grammar"
%comment "Create a Graphviz representation of `parol`'s LookaheadDFAs"
%line_comment "//"

%%

/*   0 */ LaDfa2Dot: LaDfa2DotList /* Vec */;
/*   1 */ LaDfa2DotList /* `Vec<T>::Push` */: AttributeOpt^ /* Clipped */ CommentOpt^ /* Clipped */ Item LaDfa2DotList;
/*   2 */ LaDfa2DotList /* `Vec<T>::New` */: ;
/*   3 */ AttributeOpt: AttributeOpt0 /* Option */;
/*   4 */ AttributeOpt0 /* `Option<T>::Some` */: Hash LBracket Ident AttributeArgOpt RBracket;
/*   5 */ AttributeOpt0 /* `Option<T>::None` */: ;
/*   6 */ AttributeArgOpt: AttributeArgOpt0 /* Option */;
/*   7 */ AttributeArgOpt0 /* `Option<T>::Some` */: LParen Ident RParen;
/*   8 */ AttributeArgOpt0 /* `Option<T>::None` */: ;
/*   9 */ Item: UseStatement^ /* Clipped */;
/*  10 */ Item: ConstDeclaration;
/*  11 */ UseStatement: 'use' ScopedQualifiedIdent Semicolon;
/*  12 */ QualifiedIdent: Ident QualifiedIdentList /* Vec */;
/*  13 */ QualifiedIdentList /* `Vec<T>::Push` */: DoubleColon Ident QualifiedIdentList;
/*  14 */ QualifiedIdentList /* `Vec<T>::New` */: ;
/*  15 */ ScopedQualifiedIdent: QualifiedIdent ScopedQualifiedIdentOpt /* Option */;
/*  16 */ ScopedQualifiedIdentOpt /* `Option<T>::Some` */: DoubleColon ScopedList;
/*  17 */ ScopedQualifiedIdentOpt /* `Option<T>::None` */: ;
/*  18 */ ScopedList: LBrace ScopedListItems CommaOpt RBrace;
/*  19 */ ScopedListItems: ScopedQualifiedIdent ScopedListItemsList /* Vec */;
/*  20 */ ScopedListItemsList /* `Vec<T>::Push` */: Comma^ /* Clipped */ ScopedQualifiedIdent ScopedListItemsList;
/*  21 */ ScopedListItemsList /* `Vec<T>::New` */: ;
/*  22 */ ConstDeclaration: ConstPreamble TypeSpec Assign CommentOptConstVal Semicolon;
/*  23 */ ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;
/*  24 */ ConstPreamble: ConstQualifier ConstName Colon;
/*  25 */ ConstQualifier: ConstQualifierOpt /* Option */ 'const';
/*  26 */ ConstQualifier: 'static';
/*  27 */ ConstQualifierOpt /* `Option<T>::Some` */: 'pub';
/*  28 */ ConstQualifierOpt /* `Option<T>::None` */: ;
/*  29 */ ConstName: Ident;
/*  30 */ CommentOptConstVal: CommentOpt InnerConstVal;
/*  31 */ InnerConstVal: Number;
/*  32 */ InnerConstVal: String;
/*  33 */ InnerConstVal: QualifiedVal;
/*  34 */ InnerConstVal: ArrayVal;
/*  35 */ InnerConstVal: TupleVal;
/*  36 */ ArrayVal: Ref LBracket ArrayValOpt /* Option */ RBracket;
/*  37 */ ArrayValOpt /* `Option<T>::Some` */: ConstValList CommaOpt;
/*  38 */ ArrayValOpt /* `Option<T>::None` */: ;
/*  39 */ ConstValList: CommentOptConstVal ConstValListList /* Vec */ CommentOpt CommaOpt;
/*  40 */ ConstValListList /* `Vec<T>::Push` */: CommentOpt Comma CommentOptConstVal ConstValListList;
/*  41 */ ConstValListList /* `Vec<T>::New` */: ;
/*  42 */ TupleVal: LParen TupleValOpt /* Option */ RParen;
/*  43 */ TupleValOpt /* `Option<T>::Some` */: ConstValList CommaOpt;
/*  44 */ TupleValOpt /* `Option<T>::None` */: ;
/*  45 */ QualifiedVal: QualifiedIdent QualifiedValOpt /* Option */;
/*  46 */ QualifiedValOpt /* `Option<T>::Some` */: StructOrTupleVal;
/*  47 */ QualifiedValOpt /* `Option<T>::None` */: ;
/*  48 */ StructOrTupleVal: StructVal;
/*  49 */ StructOrTupleVal: TupleStructVal;
/*  50 */ StructVal: LBrace StructValOpt /* Option */ RBrace;
/*  51 */ StructValOpt /* `Option<T>::Some` */: MemberValues Comma;
/*  52 */ StructValOpt /* `Option<T>::None` */: ;
/*  53 */ MemberValues: MemberValue MemberValuesList /* Vec */;
/*  54 */ MemberValuesList /* `Vec<T>::Push` */: Comma MemberValue MemberValuesList;
/*  55 */ MemberValuesList /* `Vec<T>::New` */: ;
/*  56 */ MemberValue: Ident Colon CommentOptConstVal;
/*  57 */ TupleStructVal: TupleVal;
/*  58 */ TypeSpec: QualifiedIdent;
/*  59 */ TypeSpec: ArrayType;
/*  60 */ TypeSpec: TupleType;
/*  61 */ ArrayType: Ref LBracket ArrayTypeSpec RBracket;
/*  62 */ ArrayTypeSpec: ArrayTypeSpecOpt /* Option */ Ident Semicolon Number;
/*  63 */ ArrayTypeSpecOpt /* `Option<T>::Some` */: Ref;
/*  64 */ ArrayTypeSpecOpt /* `Option<T>::None` */: ;
/*  65 */ TupleType: LParen TupleItems CommaOpt RParen;
/*  66 */ TupleItems: TypeSpec TupleItemsList /* Vec */;
/*  67 */ TupleItemsList /* `Vec<T>::Push` */: Comma TypeSpec TupleItemsList;
/*  68 */ TupleItemsList /* `Vec<T>::New` */: ;
/*  69 */ Skip: /(?s)&\[Production; \d+\] = &\[.*(?-s)/;
/*  70 */ CommaOpt: CommaOpt0 /* Option */;
/*  71 */ CommaOpt0 /* `Option<T>::Some` */: Comma;
/*  72 */ CommaOpt0 /* `Option<T>::None` */: ;
/*  73 */ CommentOpt: CommentOpt0 /* Option */;
/*  74 */ CommentOpt0 /* `Option<T>::Some` */: CommentVariants;
/*  75 */ CommentOpt0 /* `Option<T>::None` */: ;
/*  76 */ CommentVariants: IgnoredComment^ /* Clipped */;
/*  77 */ CommentVariants: NamingComment;
/*  78 */ NamingComment: BlockCommentStart^ /* Clipped */ Number Dash^ /* Clipped */ String BlockCommentEnd^ /* Clipped */;
/*  79 */ IgnoredComment: BlockCommentStart^ /* Clipped */ IgnoredCommentSuffix0;
/*  80 */ IgnoredCommentSuffix0: Ident^ /* Clipped */ IgnoredCommentSuffix;
/*  81 */ IgnoredCommentSuffix0: Number^ /* Clipped */ BlockCommentEnd^ /* Clipped */;
/*  82 */ IgnoredCommentSuffix: Colon^ /* Clipped */ String^ /* Clipped */ BlockCommentEnd^ /* Clipped */;
/*  83 */ IgnoredCommentSuffix: BlockCommentEnd^ /* Clipped */;
/*  84 */ BlockCommentStart: "/\*"^ /* Clipped */;
/*  85 */ BlockCommentEnd: "\*/"^ /* Clipped */;
/*  86 */ Assign: '=';
/*  87 */ Number: /-?\d+/;
/*  88 */ Ref: '&';
/*  89 */ Semicolon: ';';
/*  90 */ Comma: ',';
/*  91 */ String: /(r#*)?"(\\.|[^\\])*?"#*/;
/*  92 */ Ident: /[a-zA-Z_][a-zA-Z0-9_]*/;
/*  93 */ DoubleColon: '::';
/*  94 */ Colon: ':';
/*  95 */ LBrace: '{';
/*  96 */ RBrace: '}';
/*  97 */ LBracket: '[';
/*  98 */ RBracket: ']';
/*  99 */ LParen: '(';
/* 100 */ RParen: ')';
/* 101 */ Hash: /#/;
/* 102 */ Dash: '-';
