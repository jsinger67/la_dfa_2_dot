// This grammar is made to only be able to parse generated parser sources.
// No claim to parse full Rust.
// It even skips parts of the file after all necessary information is gathered (see 'Skip' below).
// The real new thing here is that we use the new comment preserving feature of
// parol 0.22.0 and parol_runtime 0.17.0.
%start LaDfa2Dot
%title "LaDfa2Dot grammar"
%comment "Create a Graphviz representation of `parol`'s LookaheadDFAs"
%line_comment '//'
%block_comment '/*' '*/'
%on RawStringStart %enter RAW_STRING
%on RawString1Start %enter RAW_STRING1
%on RawString2Start %enter RAW_STRING2
%on RawString3Start %enter RAW_STRING3

%scanner RAW_STRING {
    %auto_newline_off
    %auto_ws_off
    %on RawStringEnd %enter INITIAL
}
%scanner RAW_STRING1 {
    %auto_newline_off
    %auto_ws_off
    %allow_unmatched
    %on RawString1End %enter INITIAL
}
%scanner RAW_STRING2 {
    %auto_newline_off
    %auto_ws_off
    %allow_unmatched
    %on RawString2End %enter INITIAL
}
%scanner RAW_STRING3 {
    %auto_newline_off
    %auto_ws_off
    %allow_unmatched
    %on RawString3End %enter INITIAL
}

%%

LaDfa2Dot
    : { AttributeOpt^ Item }
    ;

AttributeOpt
    : [ Hash LBracket Ident AttributeArgOpt RBracket ]
    ;

AttributeArgOpt
    : [ LParen Ident RParen ]
    ;

Item: UseStatement^
    | ConstDeclaration
    | ScannerMacro
    ;

// -------------------------------------------------------------------------------------------------
// UseStatement
// -------------------------------------------------------------------------------------------------
UseStatement
    : 'use' ScopedQualifiedIdent Semicolon
    ;

QualifiedIdent
    : Ident { DoubleColon Ident }
    ;

ScopedQualifiedIdent
    : QualifiedIdent [ DoubleColon ScopedList ]
    ;

ScopedList
    : LBrace ScopedListItems CommaOpt RBrace
    ;

ScopedListItems
    : ScopedQualifiedIdent { Comma^ ScopedQualifiedIdent }
    ;

// -------------------------------------------------------------------------------------------------
// ConstDeclaration
// -------------------------------------------------------------------------------------------------
ConstDeclaration
    : ConstPreamble TypeSpec^ Assign^ ConstVal Semicolon^
    | ConstPreamble^ Skip^
    ;

ConstPreamble
    : ConstQualifier^ ConstName Colon^
    ;

ConstQualifier
    : [ 'pub' ] 'const'
    | 'static'
    ;

ConstName
    : Ident
    ;

ConstVal
    : Number
    | String
    | QualifiedVal
    | ArrayVal
    | TupleVal
    ;

ArrayVal
    : Ref^ LBracket^ [ ConstValList CommaOpt^ ] RBracket^
    ;

ConstValList
    : ConstVal { Comma^ ConstVal }
    ;

TupleVal
    : LParen^ [ ConstValList CommaOpt^ ] RParen^
    ;

QualifiedVal
    : QualifiedIdent [ StructOrTupleVal ]
    ;

StructOrTupleVal
    : StructVal
    | TupleStructVal
    ;

StructVal
    : LBrace^ [ MemberValues Comma^ ] RBrace^
    ;

MemberValues
    : MemberValue { Comma^ MemberValue }
    ;

MemberValue
    : Ident Colon^ ConstVal
    ;

TupleStructVal
    : TupleVal
    ;

// -------------------------------------------------------------------------------------------------
// ScannerMacro
// -------------------------------------------------------------------------------------------------
ScannerMacro
    : 'scanner!' LBrace^ ScannerMacroBody^ RBrace^
    ;

ScannerMacroBody
    : Ident^ LBrace^ ScannerMacroItem^ { ScannerMacroItem^ } RBrace^
    ;

ScannerMacroItem
    : 'mode'^ Ident^ LBrace^ { TokenDefinition^ | ModeTransition^ } RBrace^
    ;

TokenDefinition
    : 'token'^ String^ [ LookaheadExpression^ ] Arrow^ Number^ Semicolon^
    ;

ModeTransition
    : 'on'^ Number^ 'enter'^ Ident^ Semicolon^
    ;

LookaheadExpression
    : [ 'not' ] 'followed'^ 'by'^ String^
    ;

// -------------------------------------------------------------------------------------------------
// TypeSpec
// -------------------------------------------------------------------------------------------------
TypeSpec
    : QualifiedIdent
    | ArrayType
    | TupleType
    | OptionType
    ;

ArrayType
    : Ref LBracket ArrayTypeSpec RBracket
    ;

ArrayTypeSpec
    : [ Ref ] ArrayElementType Semicolon Number
    ;

ArrayElementType
    : Ident
    | Tuple
    ;

OptionType
    : 'Option' LT TypeSpec GT
    ;

Tuple
    : LParen TupleItems CommaOpt RParen
    ;

TupleType
    : LParen TupleItems CommaOpt RParen
    ;

TupleItems
    : [ Ref ] TypeSpec { Comma [ Ref ] TypeSpec }
    ;

// We ignore the rest of the file from here on because we have parsed all necessary information
Skip: /&\[Production; \d+\] = &\[(?s).*/
    ;

// -------------------------------------------------------------------------------------------------
// Optionals
// -------------------------------------------------------------------------------------------------
CommaOpt
    : [ Comma ]
    ;

// -------------------------------------------------------------------------------------------------
// Token definitions
// -------------------------------------------------------------------------------------------------
Assign
    : '='
    ;

Number
    : /-?\d+/
    ;

Ref : '&'
    ;

Arrow
    : '=>'
    ;

Semicolon
    : ';'
    ;

Comma
    : ','
    ;

String
    : QuotedString
    | RawString
    | RawString1
    | RawString2
    | RawString3
    ;

QuotedString
    : /"([^"]|\\")*"/
    ;

// -------------------------------------------------------------------------------------------------
// RawString
// -------------------------------------------------------------------------------------------------
RawStringStart
    : /r"/
    ;

RawStringEnd
    : <RAW_STRING>/"/
    ;

RawStringContent
    : <RAW_STRING>/([^"]|\\")*/
    ;

RawString
    : RawStringStart^ RawStringContent@strng RawStringEnd^
    ;

// -------------------------------------------------------------------------------------------------
// RawString1
// -------------------------------------------------------------------------------------------------
RawString1Start
    : /r#"/
    ;

RawString1End
    : <RAW_STRING1>/"#/
    ;

RawStringContentNoQuotes
    : <RAW_STRING1>/[^"]*/
    ;

RawString1ContentQuotes
    : <RAW_STRING1>/"/?!/#/
    ;

RawString1Content
    : { RawStringContentNoQuotes | RawString1ContentQuotes }
    ;

RawString1
    : RawString1Start^ RawString1Content@strng RawString1End^
    ;

// -------------------------------------------------------------------------------------------------
// RawString2
// -------------------------------------------------------------------------------------------------
RawString2Start
    : /r##"/
    ;

RawString2End
    : <RAW_STRING2>/"##/
    ;

RawString2ContentQuotes
    : <RAW_STRING2>/"/?!/##/
    ;

RawString2Content
    : { RawStringContentNoQuotes | RawString2ContentQuotes }
    ;

RawString2
    : RawString2Start^ RawString2Content@strng RawString2End^
    ;

// -------------------------------------------------------------------------------------------------
// RawString3
// -------------------------------------------------------------------------------------------------
RawString3Start
    : /r\u{0023}{3}"/
    ;

RawString3End
    : <RAW_STRING3>/"\u{0023}{3}/
    ;

RawString3ContentQuotes
    : <RAW_STRING3>/"/?!/\u{0023}{3}/
    ;

RawString3Content
    : { RawStringContentNoQuotes | RawString3ContentQuotes }
    ;

RawString3
    : RawString3Start^ RawString3Content@strng RawString3End^
    ;

// -------------------------------------------------------------------------------------------------
// Ident
// -------------------------------------------------------------------------------------------------
Ident
    : /[a-zA-Z_][a-zA-Z0-9_]*/
    ;

DoubleColon
    : '::'
    ;

Colon
    : ':'
    ;

LBrace
    : '{'
    ;

RBrace
    : '}'
    ;

LBracket
    : '['
    ;

RBracket
    : ']'
    ;

LParen
    : '('
    ;

RParen
    : ')'
    ;

Hash: /#/
    ;

LT  : '<'
    ;

GT  : '>'
    ;
