// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait LaDfa2DotGrammarTrait<'t> {
    /// Semantic action for non-terminal 'LaDfa2Dot'
    fn la_dfa2_dot(&mut self, _arg: &LaDfa2Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeOpt'
    fn attribute_opt(&mut self, _arg: &AttributeOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeArgOpt'
    fn attribute_arg_opt(&mut self, _arg: &AttributeArgOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Item'
    fn item(&mut self, _arg: &Item<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UseStatement'
    fn use_statement(&mut self, _arg: &UseStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualifiedIdent'
    fn qualified_ident(&mut self, _arg: &QualifiedIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedQualifiedIdent'
    fn scoped_qualified_ident(&mut self, _arg: &ScopedQualifiedIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedList'
    fn scoped_list(&mut self, _arg: &ScopedList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedListItems'
    fn scoped_list_items(&mut self, _arg: &ScopedListItems<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDeclaration'
    fn const_declaration(&mut self, _arg: &ConstDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstPreamble'
    fn const_preamble(&mut self, _arg: &ConstPreamble<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstQualifier'
    fn const_qualifier(&mut self, _arg: &ConstQualifier<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstName'
    fn const_name(&mut self, _arg: &ConstName<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstVal'
    fn const_val(&mut self, _arg: &ConstVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayVal'
    fn array_val(&mut self, _arg: &ArrayVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstValList'
    fn const_val_list(&mut self, _arg: &ConstValList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleVal'
    fn tuple_val(&mut self, _arg: &TupleVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualifiedVal'
    fn qualified_val(&mut self, _arg: &QualifiedVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructOrTupleVal'
    fn struct_or_tuple_val(&mut self, _arg: &StructOrTupleVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructVal'
    fn struct_val(&mut self, _arg: &StructVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MemberValues'
    fn member_values(&mut self, _arg: &MemberValues<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MemberValue'
    fn member_value(&mut self, _arg: &MemberValue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleStructVal'
    fn tuple_struct_val(&mut self, _arg: &TupleStructVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeSpec'
    fn type_spec(&mut self, _arg: &TypeSpec<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayType'
    fn array_type(&mut self, _arg: &ArrayType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTypeSpec'
    fn array_type_spec(&mut self, _arg: &ArrayTypeSpec<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElementType'
    fn array_element_type(&mut self, _arg: &ArrayElementType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OptionType'
    fn option_type(&mut self, _arg: &OptionType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tuple'
    fn tuple(&mut self, _arg: &Tuple<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleType'
    fn tuple_type(&mut self, _arg: &TupleType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleItems'
    fn tuple_items(&mut self, _arg: &TupleItems<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Skip'
    fn skip(&mut self, _arg: &Skip<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaOpt'
    fn comma_opt(&mut self, _arg: &CommaOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ref'
    fn r#ref(&mut self, _arg: &Ref<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotedString'
    fn quoted_string(&mut self, _arg: &QuotedString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString'
    fn raw_string(&mut self, _arg: &RawString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleColon'
    fn double_colon(&mut self, _arg: &DoubleColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LT'
    fn l_t(&mut self, _arg: &LT<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GT'
    fn g_t(&mut self, _arg: &GT<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 9
///
/// `Item: UseStatement^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ItemUseStatement {}

///
/// Type derived for production 10
///
/// `Item: ConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ItemConstDeclaration<'t> {
    pub const_declaration: ConstDeclaration<'t>,
}

///
/// Type derived for production 22
///
/// `ConstDeclaration: ConstPreamble TypeSpec^ /* Clipped */ Assign^ /* Clipped */ ConstVal Semicolon^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon<'t> {
    pub const_preamble: ConstPreamble<'t>,
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for production 23
///
/// `ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstDeclarationConstPreambleSkip {}

///
/// Type derived for production 25
///
/// `ConstQualifier: ConstQualifierOpt /* Option */ 'const';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstQualifierConstQualifierOptConst<'t> {
    pub const_qualifier_opt: Option<ConstQualifierOpt<'t>>,
    pub r#const: Token<'t>, /* const */
}

///
/// Type derived for production 26
///
/// `ConstQualifier: 'static';`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstQualifierStatic<'t> {
    pub r#static: Token<'t>, /* static */
}

///
/// Type derived for production 30
///
/// `ConstVal: Number;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValNumber<'t> {
    pub number: Number<'t>,
}

///
/// Type derived for production 31
///
/// `ConstVal: String;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 32
///
/// `ConstVal: QualifiedVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValQualifiedVal<'t> {
    pub qualified_val: Box<QualifiedVal<'t>>,
}

///
/// Type derived for production 33
///
/// `ConstVal: ArrayVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValArrayVal<'t> {
    pub array_val: Box<ArrayVal<'t>>,
}

///
/// Type derived for production 34
///
/// `ConstVal: TupleVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValTupleVal<'t> {
    pub tuple_val: Box<TupleVal<'t>>,
}

///
/// Type derived for production 47
///
/// `StructOrTupleVal: StructVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructOrTupleValStructVal<'t> {
    pub struct_val: Box<StructVal<'t>>,
}

///
/// Type derived for production 48
///
/// `StructOrTupleVal: TupleStructVal;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructOrTupleValTupleStructVal<'t> {
    pub tuple_struct_val: TupleStructVal<'t>,
}

///
/// Type derived for production 57
///
/// `TypeSpec: QualifiedIdent;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecQualifiedIdent<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
}

///
/// Type derived for production 58
///
/// `TypeSpec: ArrayType;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecArrayType<'t> {
    pub array_type: Box<ArrayType<'t>>,
}

///
/// Type derived for production 59
///
/// `TypeSpec: TupleType;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecTupleType<'t> {
    pub tuple_type: Box<TupleType<'t>>,
}

///
/// Type derived for production 60
///
/// `TypeSpec: OptionType;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeSpecOptionType<'t> {
    pub option_type: Box<OptionType<'t>>,
}

///
/// Type derived for production 65
///
/// `ArrayElementType: Ident;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayElementTypeIdent<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for production 66
///
/// `ArrayElementType: Tuple;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayElementTypeTuple<'t> {
    pub tuple: Tuple<'t>,
}

///
/// Type derived for production 86
///
/// `String: QuotedString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringQuotedString<'t> {
    pub quoted_string: QuotedString<'t>,
}

///
/// Type derived for production 87
///
/// `String: RawString;`
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringRawString<'t> {
    pub raw_string: RawString<'t>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ArrayElementType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayElementType<'t> {
    Ident(ArrayElementTypeIdent<'t>),
    Tuple(ArrayElementTypeTuple<'t>),
}

///
/// Type derived for non-terminal ArrayType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayType<'t> {
    pub r#ref: Ref<'t>,
    pub l_bracket: LBracket<'t>,
    pub array_type_spec: ArrayTypeSpec<'t>,
    pub r_bracket: RBracket<'t>,
}

///
/// Type derived for non-terminal ArrayTypeSpec
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTypeSpec<'t> {
    pub array_type_spec_opt: Option<ArrayTypeSpecOpt<'t>>,
    pub array_element_type: ArrayElementType<'t>,
    pub semicolon: Semicolon<'t>,
    pub number: Number<'t>,
}

///
/// Type derived for non-terminal ArrayTypeSpecOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTypeSpecOpt<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal ArrayVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayVal<'t> {
    pub array_val_opt: Option<ArrayValOpt<'t>>,
}

///
/// Type derived for non-terminal ArrayValOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayValOpt<'t> {
    pub const_val_list: ConstValList<'t>,
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assign<'t> {
    pub assign: Token<'t>, /* = */
}

///
/// Type derived for non-terminal AttributeArgOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeArgOpt<'t> {
    pub attribute_arg_opt0: Option<AttributeArgOpt0<'t>>,
}

///
/// Type derived for non-terminal AttributeArgOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeArgOpt0<'t> {
    pub l_paren: LParen<'t>,
    pub ident: Ident<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal AttributeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeOpt<'t> {
    pub attribute_opt0: Option<AttributeOpt0<'t>>,
}

///
/// Type derived for non-terminal AttributeOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeOpt0<'t> {
    pub hash: Hash<'t>,
    pub l_bracket: LBracket<'t>,
    pub ident: Ident<'t>,
    pub attribute_arg_opt: AttributeArgOpt<'t>,
    pub r_bracket: RBracket<'t>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Colon<'t> {
    pub colon: Token<'t>, /* : */
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal CommaOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaOpt<'t> {
    pub comma_opt0: Option<CommaOpt0<'t>>,
}

///
/// Type derived for non-terminal CommaOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaOpt0<'t> {
    pub comma: Comma<'t>,
}

///
/// Type derived for non-terminal ConstDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstDeclaration<'t> {
    ConstPreambleTypeSpecAssignConstValSemicolon(
        ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon<'t>,
    ),
    ConstPreambleSkip(ConstDeclarationConstPreambleSkip),
}

///
/// Type derived for non-terminal ConstName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstName<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal ConstPreamble
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstPreamble<'t> {
    pub const_name: ConstName<'t>,
}

///
/// Type derived for non-terminal ConstQualifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstQualifier<'t> {
    ConstQualifierOptConst(ConstQualifierConstQualifierOptConst<'t>),
    Static(ConstQualifierStatic<'t>),
}

///
/// Type derived for non-terminal ConstQualifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstQualifierOpt<'t> {
    pub r#pub: Token<'t>, /* pub */
}

///
/// Type derived for non-terminal ConstVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstVal<'t> {
    Number(ConstValNumber<'t>),
    String(ConstValString<'t>),
    QualifiedVal(ConstValQualifiedVal<'t>),
    ArrayVal(ConstValArrayVal<'t>),
    TupleVal(ConstValTupleVal<'t>),
}

///
/// Type derived for non-terminal ConstValList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValList<'t> {
    pub const_val: ConstVal<'t>,
    pub const_val_list_list: Vec<ConstValListList<'t>>,
}

///
/// Type derived for non-terminal ConstValListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConstValListList<'t> {
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for non-terminal DoubleColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DoubleColon<'t> {
    pub double_colon: Token<'t>, /* :: */
}

///
/// Type derived for non-terminal GT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct GT<'t> {
    pub g_t: Token<'t>, /* > */
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Hash<'t> {
    pub hash: Token<'t>, /* # */
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal Item
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Item<'t> {
    UseStatement(ItemUseStatement),
    ConstDeclaration(ItemConstDeclaration<'t>),
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBrace<'t> {
    pub l_brace: Token<'t>, /* { */
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracket<'t> {
    pub l_bracket: Token<'t>, /* [ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal LT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LT<'t> {
    pub l_t: Token<'t>, /* < */
}

///
/// Type derived for non-terminal LaDfa2Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LaDfa2Dot<'t> {
    pub la_dfa2_dot_list: Vec<LaDfa2DotList<'t>>,
}

///
/// Type derived for non-terminal LaDfa2DotList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LaDfa2DotList<'t> {
    pub item: Item<'t>,
}

///
/// Type derived for non-terminal MemberValue
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MemberValue<'t> {
    pub ident: Ident<'t>,
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for non-terminal MemberValues
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MemberValues<'t> {
    pub member_value: MemberValue<'t>,
    pub member_values_list: Vec<MemberValuesList<'t>>,
}

///
/// Type derived for non-terminal MemberValuesList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MemberValuesList<'t> {
    pub member_value: MemberValue<'t>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Number<'t> {
    pub number: Token<'t>, /* -?\d+ */
}

///
/// Type derived for non-terminal OptionType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OptionType<'t> {
    pub option: Token<'t>, /* Option */
    pub l_t: LT<'t>,
    pub type_spec: TypeSpec<'t>,
    pub g_t: GT<'t>,
}

///
/// Type derived for non-terminal QualifiedIdent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualifiedIdent<'t> {
    pub ident: Ident<'t>,
    pub qualified_ident_list: Vec<QualifiedIdentList<'t>>,
}

///
/// Type derived for non-terminal QualifiedIdentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualifiedIdentList<'t> {
    pub double_colon: DoubleColon<'t>,
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal QualifiedVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualifiedVal<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
    pub qualified_val_opt: Option<QualifiedValOpt<'t>>,
}

///
/// Type derived for non-terminal QualifiedValOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QualifiedValOpt<'t> {
    pub struct_or_tuple_val: StructOrTupleVal<'t>,
}

///
/// Type derived for non-terminal QuotedString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct QuotedString<'t> {
    pub quoted_string: Token<'t>, /* r#{0, 3}".*"#{0, 3} */
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBrace<'t> {
    pub r_brace: Token<'t>, /* } */
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracket<'t> {
    pub r_bracket: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal RawString
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RawString<'t> {
    pub raw_string: Token<'t>, /* "(\\"|[^"])*" */
}

///
/// Type derived for non-terminal Ref
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ref<'t> {
    pub r#ref: Token<'t>, /* & */
}

///
/// Type derived for non-terminal ScopedList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedList<'t> {
    pub l_brace: LBrace<'t>,
    pub scoped_list_items: Box<ScopedListItems<'t>>,
    pub comma_opt: CommaOpt<'t>,
    pub r_brace: RBrace<'t>,
}

///
/// Type derived for non-terminal ScopedListItems
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedListItems<'t> {
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
    pub scoped_list_items_list: Vec<ScopedListItemsList<'t>>,
}

///
/// Type derived for non-terminal ScopedListItemsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedListItemsList<'t> {
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
}

///
/// Type derived for non-terminal ScopedQualifiedIdent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedQualifiedIdent<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
    pub scoped_qualified_ident_opt: Option<ScopedQualifiedIdentOpt<'t>>,
}

///
/// Type derived for non-terminal ScopedQualifiedIdentOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedQualifiedIdentOpt<'t> {
    pub double_colon: DoubleColon<'t>,
    pub scoped_list: ScopedList<'t>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Semicolon<'t> {
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal Skip
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Skip<'t> {
    pub skip: Token<'t>, /* &\[Production; \d+\] = &\[[.\r\n]* */
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum String<'t> {
    QuotedString(StringQuotedString<'t>),
    RawString(StringRawString<'t>),
}

///
/// Type derived for non-terminal StructOrTupleVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StructOrTupleVal<'t> {
    StructVal(StructOrTupleValStructVal<'t>),
    TupleStructVal(StructOrTupleValTupleStructVal<'t>),
}

///
/// Type derived for non-terminal StructVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructVal<'t> {
    pub struct_val_opt: Option<StructValOpt<'t>>,
}

///
/// Type derived for non-terminal StructValOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructValOpt<'t> {
    pub member_values: MemberValues<'t>,
}

///
/// Type derived for non-terminal Tuple
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Tuple<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_items: TupleItems<'t>,
    pub comma_opt: CommaOpt<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal TupleItems
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleItems<'t> {
    pub tuple_items_opt: Option<TupleItemsOpt<'t>>,
    pub type_spec: TypeSpec<'t>,
    pub tuple_items_list: Vec<TupleItemsList<'t>>,
}

///
/// Type derived for non-terminal TupleItemsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleItemsList<'t> {
    pub comma: Comma<'t>,
    pub tuple_items_opt0: Option<TupleItemsOpt0<'t>>,
    pub type_spec: TypeSpec<'t>,
}

///
/// Type derived for non-terminal TupleItemsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleItemsOpt<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal TupleItemsOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleItemsOpt0<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal TupleStructVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleStructVal<'t> {
    pub tuple_val: TupleVal<'t>,
}

///
/// Type derived for non-terminal TupleType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleType<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_items: TupleItems<'t>,
    pub comma_opt: CommaOpt<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal TupleVal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleVal<'t> {
    pub tuple_val_opt: Option<TupleValOpt<'t>>,
}

///
/// Type derived for non-terminal TupleValOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TupleValOpt<'t> {
    pub const_val_list: ConstValList<'t>,
}

///
/// Type derived for non-terminal TypeSpec
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeSpec<'t> {
    QualifiedIdent(TypeSpecQualifiedIdent<'t>),
    ArrayType(TypeSpecArrayType<'t>),
    TupleType(TypeSpecTupleType<'t>),
    OptionType(TypeSpecOptionType<'t>),
}

///
/// Type derived for non-terminal UseStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UseStatement<'t> {
    pub r#use: Token<'t>, /* use */
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
    pub semicolon: Semicolon<'t>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    ArrayElementType(ArrayElementType<'t>),
    ArrayType(ArrayType<'t>),
    ArrayTypeSpec(ArrayTypeSpec<'t>),
    ArrayTypeSpecOpt(Option<ArrayTypeSpecOpt<'t>>),
    ArrayVal(ArrayVal<'t>),
    ArrayValOpt(Option<ArrayValOpt<'t>>),
    Assign(Assign<'t>),
    AttributeArgOpt(AttributeArgOpt<'t>),
    AttributeArgOpt0(Option<AttributeArgOpt0<'t>>),
    AttributeOpt(AttributeOpt<'t>),
    AttributeOpt0(Option<AttributeOpt0<'t>>),
    Colon(Colon<'t>),
    Comma(Comma<'t>),
    CommaOpt(CommaOpt<'t>),
    CommaOpt0(Option<CommaOpt0<'t>>),
    ConstDeclaration(ConstDeclaration<'t>),
    ConstName(ConstName<'t>),
    ConstPreamble(ConstPreamble<'t>),
    ConstQualifier(ConstQualifier<'t>),
    ConstQualifierOpt(Option<ConstQualifierOpt<'t>>),
    ConstVal(ConstVal<'t>),
    ConstValList(ConstValList<'t>),
    ConstValListList(Vec<ConstValListList<'t>>),
    DoubleColon(DoubleColon<'t>),
    GT(GT<'t>),
    Hash(Hash<'t>),
    Ident(Ident<'t>),
    Item(Item<'t>),
    LBrace(LBrace<'t>),
    LBracket(LBracket<'t>),
    LParen(LParen<'t>),
    LT(LT<'t>),
    LaDfa2Dot(LaDfa2Dot<'t>),
    LaDfa2DotList(Vec<LaDfa2DotList<'t>>),
    MemberValue(MemberValue<'t>),
    MemberValues(MemberValues<'t>),
    MemberValuesList(Vec<MemberValuesList<'t>>),
    Number(Number<'t>),
    OptionType(OptionType<'t>),
    QualifiedIdent(QualifiedIdent<'t>),
    QualifiedIdentList(Vec<QualifiedIdentList<'t>>),
    QualifiedVal(QualifiedVal<'t>),
    QualifiedValOpt(Option<QualifiedValOpt<'t>>),
    QuotedString(QuotedString<'t>),
    RBrace(RBrace<'t>),
    RBracket(RBracket<'t>),
    RParen(RParen<'t>),
    RawString(RawString<'t>),
    Ref(Ref<'t>),
    ScopedList(ScopedList<'t>),
    ScopedListItems(ScopedListItems<'t>),
    ScopedListItemsList(Vec<ScopedListItemsList<'t>>),
    ScopedQualifiedIdent(ScopedQualifiedIdent<'t>),
    ScopedQualifiedIdentOpt(Option<ScopedQualifiedIdentOpt<'t>>),
    Semicolon(Semicolon<'t>),
    Skip(Skip<'t>),
    String(String<'t>),
    StructOrTupleVal(StructOrTupleVal<'t>),
    StructVal(StructVal<'t>),
    StructValOpt(Option<StructValOpt<'t>>),
    Tuple(Tuple<'t>),
    TupleItems(TupleItems<'t>),
    TupleItemsList(Vec<TupleItemsList<'t>>),
    TupleItemsOpt(Option<TupleItemsOpt<'t>>),
    TupleItemsOpt0(Option<TupleItemsOpt0<'t>>),
    TupleStructVal(TupleStructVal<'t>),
    TupleType(TupleType<'t>),
    TupleVal(TupleVal<'t>),
    TupleValOpt(Option<TupleValOpt<'t>>),
    TypeSpec(TypeSpec<'t>),
    UseStatement(UseStatement<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct LaDfa2DotGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `LaDfa2DotGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> LaDfa2DotGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `LaDfa2Dot: LaDfa2DotList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot(&mut self, _la_dfa2_dot_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let la_dfa2_dot_list =
            pop_and_reverse_item!(self, la_dfa2_dot_list, LaDfa2DotList, context);
        let la_dfa2_dot_built = LaDfa2Dot { la_dfa2_dot_list };
        // Calling user action here
        self.user_grammar.la_dfa2_dot(&la_dfa2_dot_built)?;
        self.push(ASTType::LaDfa2Dot(la_dfa2_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `LaDfa2DotList /* Vec<T>::Push */: AttributeOpt^ /* Clipped */ Item LaDfa2DotList;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot_list_0(
        &mut self,
        _attribute_opt: &ParseTreeType<'t>,
        _item: &ParseTreeType<'t>,
        _la_dfa2_dot_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut la_dfa2_dot_list = pop_item!(self, la_dfa2_dot_list, LaDfa2DotList, context);
        let item = pop_item!(self, item, Item, context);
        self.pop(context);
        let la_dfa2_dot_list_0_built = LaDfa2DotList { item };
        // Add an element to the vector
        la_dfa2_dot_list.push(la_dfa2_dot_list_0_built);
        self.push(ASTType::LaDfa2DotList(la_dfa2_dot_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `LaDfa2DotList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let la_dfa2_dot_list_1_built = Vec::new();
        self.push(ASTType::LaDfa2DotList(la_dfa2_dot_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `AttributeOpt: AttributeOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt(&mut self, _attribute_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_opt0 = pop_item!(self, attribute_opt0, AttributeOpt0, context);
        let attribute_opt_built = AttributeOpt { attribute_opt0 };
        // Calling user action here
        self.user_grammar.attribute_opt(&attribute_opt_built)?;
        self.push(ASTType::AttributeOpt(attribute_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `AttributeOpt0 /* Option<T>::Some */: Hash LBracket Ident AttributeArgOpt RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt0_0(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _attribute_arg_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let attribute_arg_opt = pop_item!(self, attribute_arg_opt, AttributeArgOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let hash = pop_item!(self, hash, Hash, context);
        let attribute_opt0_0_built = AttributeOpt0 {
            hash,
            l_bracket,
            ident,
            attribute_arg_opt,
            r_bracket,
        };
        self.push(
            ASTType::AttributeOpt0(Some(attribute_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `AttributeOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `AttributeArgOpt: AttributeArgOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt(&mut self, _attribute_arg_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_arg_opt0 = pop_item!(self, attribute_arg_opt0, AttributeArgOpt0, context);
        let attribute_arg_opt_built = AttributeArgOpt { attribute_arg_opt0 };
        // Calling user action here
        self.user_grammar
            .attribute_arg_opt(&attribute_arg_opt_built)?;
        self.push(ASTType::AttributeArgOpt(attribute_arg_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `AttributeArgOpt0 /* Option<T>::Some */: LParen Ident RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt0_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let ident = pop_item!(self, ident, Ident, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let attribute_arg_opt0_0_built = AttributeArgOpt0 {
            l_paren,
            ident,
            r_paren,
        };
        self.push(
            ASTType::AttributeArgOpt0(Some(attribute_arg_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `AttributeArgOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeArgOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Item: UseStatement^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn item_0(&mut self, _use_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let item_0_built = ItemUseStatement {};
        let item_0_built = Item::UseStatement(item_0_built);
        // Calling user action here
        self.user_grammar.item(&item_0_built)?;
        self.push(ASTType::Item(item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `Item: ConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn item_1(&mut self, _const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_declaration = pop_item!(self, const_declaration, ConstDeclaration, context);
        let item_1_built = ItemConstDeclaration { const_declaration };
        let item_1_built = Item::ConstDeclaration(item_1_built);
        // Calling user action here
        self.user_grammar.item(&item_1_built)?;
        self.push(ASTType::Item(item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `UseStatement: 'use' ScopedQualifiedIdent Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn use_statement(
        &mut self,
        r#use: &ParseTreeType<'t>,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#use = r#use.token()?.clone();
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        let use_statement_built = UseStatement {
            r#use,
            scoped_qualified_ident,
            semicolon,
        };
        // Calling user action here
        self.user_grammar.use_statement(&use_statement_built)?;
        self.push(ASTType::UseStatement(use_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `QualifiedIdent: Ident QualifiedIdentList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _qualified_ident_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident_list =
            pop_and_reverse_item!(self, qualified_ident_list, QualifiedIdentList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let qualified_ident_built = QualifiedIdent {
            ident,
            qualified_ident_list,
        };
        // Calling user action here
        self.user_grammar.qualified_ident(&qualified_ident_built)?;
        self.push(ASTType::QualifiedIdent(qualified_ident_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `QualifiedIdentList /* Vec<T>::Push */: DoubleColon Ident QualifiedIdentList;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident_list_0(
        &mut self,
        _double_colon: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _qualified_ident_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut qualified_ident_list =
            pop_item!(self, qualified_ident_list, QualifiedIdentList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let double_colon = pop_item!(self, double_colon, DoubleColon, context);
        let qualified_ident_list_0_built = QualifiedIdentList {
            ident,
            double_colon,
        };
        // Add an element to the vector
        qualified_ident_list.push(qualified_ident_list_0_built);
        self.push(ASTType::QualifiedIdentList(qualified_ident_list), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `QualifiedIdentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident_list_1_built = Vec::new();
        self.push(
            ASTType::QualifiedIdentList(qualified_ident_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `ScopedQualifiedIdent: QualifiedIdent ScopedQualifiedIdentOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident(
        &mut self,
        _qualified_ident: &ParseTreeType<'t>,
        _scoped_qualified_ident_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_qualified_ident_opt = pop_item!(
            self,
            scoped_qualified_ident_opt,
            ScopedQualifiedIdentOpt,
            context
        );
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let scoped_qualified_ident_built = ScopedQualifiedIdent {
            qualified_ident,
            scoped_qualified_ident_opt,
        };
        // Calling user action here
        self.user_grammar
            .scoped_qualified_ident(&scoped_qualified_ident_built)?;
        self.push(
            ASTType::ScopedQualifiedIdent(scoped_qualified_ident_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `ScopedQualifiedIdentOpt /* Option<T>::Some */: DoubleColon ScopedList;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident_opt_0(
        &mut self,
        _double_colon: &ParseTreeType<'t>,
        _scoped_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list = pop_item!(self, scoped_list, ScopedList, context);
        let double_colon = pop_item!(self, double_colon, DoubleColon, context);
        let scoped_qualified_ident_opt_0_built = ScopedQualifiedIdentOpt {
            double_colon,
            scoped_list,
        };
        self.push(
            ASTType::ScopedQualifiedIdentOpt(Some(scoped_qualified_ident_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `ScopedQualifiedIdentOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScopedQualifiedIdentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `ScopedList: LBrace ScopedListItems CommaOpt RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _scoped_list_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let scoped_list_items = pop_item!(self, scoped_list_items, ScopedListItems, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let scoped_list_built = ScopedList {
            l_brace,
            scoped_list_items: Box::new(scoped_list_items),
            comma_opt,
            r_brace,
        };
        // Calling user action here
        self.user_grammar.scoped_list(&scoped_list_built)?;
        self.push(ASTType::ScopedList(scoped_list_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `ScopedListItems: ScopedQualifiedIdent ScopedListItemsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items(
        &mut self,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _scoped_list_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list_items_list =
            pop_and_reverse_item!(self, scoped_list_items_list, ScopedListItemsList, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        let scoped_list_items_built = ScopedListItems {
            scoped_qualified_ident,
            scoped_list_items_list,
        };
        // Calling user action here
        self.user_grammar
            .scoped_list_items(&scoped_list_items_built)?;
        self.push(ASTType::ScopedListItems(scoped_list_items_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `ScopedListItemsList /* Vec<T>::Push */: Comma^ /* Clipped */ ScopedQualifiedIdent ScopedListItemsList;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _scoped_list_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_list_items_list =
            pop_item!(self, scoped_list_items_list, ScopedListItemsList, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        self.pop(context);
        let scoped_list_items_list_0_built = ScopedListItemsList {
            scoped_qualified_ident,
        };
        // Add an element to the vector
        scoped_list_items_list.push(scoped_list_items_list_0_built);
        self.push(
            ASTType::ScopedListItemsList(scoped_list_items_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `ScopedListItemsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list_items_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedListItemsList(scoped_list_items_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `ConstDeclaration: ConstPreamble TypeSpec^ /* Clipped */ Assign^ /* Clipped */ ConstVal Semicolon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_0(
        &mut self,
        _const_preamble: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _assign: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        self.pop(context);
        let const_preamble = pop_item!(self, const_preamble, ConstPreamble, context);
        let const_declaration_0_built =
            ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon {
                const_preamble,
                const_val,
            };
        let const_declaration_0_built =
            ConstDeclaration::ConstPreambleTypeSpecAssignConstValSemicolon(
                const_declaration_0_built,
            );
        // Calling user action here
        self.user_grammar
            .const_declaration(&const_declaration_0_built)?;
        self.push(
            ASTType::ConstDeclaration(const_declaration_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_1(
        &mut self,
        _const_preamble: &ParseTreeType<'t>,
        _skip: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let const_declaration_1_built = ConstDeclarationConstPreambleSkip {};
        let const_declaration_1_built =
            ConstDeclaration::ConstPreambleSkip(const_declaration_1_built);
        // Calling user action here
        self.user_grammar
            .const_declaration(&const_declaration_1_built)?;
        self.push(
            ASTType::ConstDeclaration(const_declaration_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `ConstPreamble: ConstQualifier^ /* Clipped */ ConstName Colon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_preamble(
        &mut self,
        _const_qualifier: &ParseTreeType<'t>,
        _const_name: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_name = pop_item!(self, const_name, ConstName, context);
        self.pop(context);
        let const_preamble_built = ConstPreamble { const_name };
        // Calling user action here
        self.user_grammar.const_preamble(&const_preamble_built)?;
        self.push(ASTType::ConstPreamble(const_preamble_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ConstQualifier: ConstQualifierOpt /* Option */ 'const';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_0(
        &mut self,
        _const_qualifier_opt: &ParseTreeType<'t>,
        r#const: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#const = r#const.token()?.clone();
        let const_qualifier_opt = pop_item!(self, const_qualifier_opt, ConstQualifierOpt, context);
        let const_qualifier_0_built = ConstQualifierConstQualifierOptConst {
            const_qualifier_opt,
            r#const,
        };
        let const_qualifier_0_built =
            ConstQualifier::ConstQualifierOptConst(const_qualifier_0_built);
        // Calling user action here
        self.user_grammar
            .const_qualifier(&const_qualifier_0_built)?;
        self.push(ASTType::ConstQualifier(const_qualifier_0_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `ConstQualifier: 'static';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_1(&mut self, r#static: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#static = r#static.token()?.clone();
        let const_qualifier_1_built = ConstQualifierStatic { r#static };
        let const_qualifier_1_built = ConstQualifier::Static(const_qualifier_1_built);
        // Calling user action here
        self.user_grammar
            .const_qualifier(&const_qualifier_1_built)?;
        self.push(ASTType::ConstQualifier(const_qualifier_1_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ConstQualifierOpt /* Option<T>::Some */: 'pub';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_opt_0(&mut self, r#pub: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#pub = r#pub.token()?.clone();
        let const_qualifier_opt_0_built = ConstQualifierOpt { r#pub };
        self.push(
            ASTType::ConstQualifierOpt(Some(const_qualifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `ConstQualifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConstQualifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ConstName: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn const_name(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let const_name_built = ConstName { ident };
        // Calling user action here
        self.user_grammar.const_name(&const_name_built)?;
        self.push(ASTType::ConstName(const_name_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `ConstVal: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_0(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let const_val_0_built = ConstValNumber { number };
        let const_val_0_built = ConstVal::Number(const_val_0_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_0_built)?;
        self.push(ASTType::ConstVal(const_val_0_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `ConstVal: String;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let const_val_1_built = ConstValString { string };
        let const_val_1_built = ConstVal::String(const_val_1_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_1_built)?;
        self.push(ASTType::ConstVal(const_val_1_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `ConstVal: QualifiedVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_2(&mut self, _qualified_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_val = pop_item!(self, qualified_val, QualifiedVal, context);
        let const_val_2_built = ConstValQualifiedVal {
            qualified_val: Box::new(qualified_val),
        };
        let const_val_2_built = ConstVal::QualifiedVal(const_val_2_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_2_built)?;
        self.push(ASTType::ConstVal(const_val_2_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `ConstVal: ArrayVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_3(&mut self, _array_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_val = pop_item!(self, array_val, ArrayVal, context);
        let const_val_3_built = ConstValArrayVal {
            array_val: Box::new(array_val),
        };
        let const_val_3_built = ConstVal::ArrayVal(const_val_3_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_3_built)?;
        self.push(ASTType::ConstVal(const_val_3_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `ConstVal: TupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_4(&mut self, _tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_val = pop_item!(self, tuple_val, TupleVal, context);
        let const_val_4_built = ConstValTupleVal {
            tuple_val: Box::new(tuple_val),
        };
        let const_val_4_built = ConstVal::TupleVal(const_val_4_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_4_built)?;
        self.push(ASTType::ConstVal(const_val_4_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `ArrayVal: Ref^ /* Clipped */ LBracket^ /* Clipped */ ArrayValOpt /* Option */ RBracket^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val(
        &mut self,
        _ref: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _array_val_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let array_val_opt = pop_item!(self, array_val_opt, ArrayValOpt, context);
        self.pop(context);
        self.pop(context);
        let array_val_built = ArrayVal { array_val_opt };
        // Calling user action here
        self.user_grammar.array_val(&array_val_built)?;
        self.push(ASTType::ArrayVal(array_val_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `ArrayValOpt /* Option<T>::Some */: ConstValList CommaOpt^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val_opt_0(
        &mut self,
        _const_val_list: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val_list = pop_item!(self, const_val_list, ConstValList, context);
        let array_val_opt_0_built = ArrayValOpt { const_val_list };
        self.push(ASTType::ArrayValOpt(Some(array_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `ArrayValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `ConstValList: ConstVal ConstValListList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list(
        &mut self,
        _const_val: &ParseTreeType<'t>,
        _const_val_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val_list_list =
            pop_and_reverse_item!(self, const_val_list_list, ConstValListList, context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        let const_val_list_built = ConstValList {
            const_val,
            const_val_list_list,
        };
        // Calling user action here
        self.user_grammar.const_val_list(&const_val_list_built)?;
        self.push(ASTType::ConstValList(const_val_list_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `ConstValListList /* Vec<T>::Push */: Comma^ /* Clipped */ ConstVal ConstValListList;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
        _const_val_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut const_val_list_list =
            pop_item!(self, const_val_list_list, ConstValListList, context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        let const_val_list_list_0_built = ConstValListList { const_val };
        // Add an element to the vector
        const_val_list_list.push(const_val_list_list_0_built);
        self.push(ASTType::ConstValListList(const_val_list_list), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `ConstValListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val_list_list_1_built = Vec::new();
        self.push(
            ASTType::ConstValListList(const_val_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `TupleVal: LParen^ /* Clipped */ TupleValOpt /* Option */ RParen^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_val_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let tuple_val_opt = pop_item!(self, tuple_val_opt, TupleValOpt, context);
        self.pop(context);
        let tuple_val_built = TupleVal { tuple_val_opt };
        // Calling user action here
        self.user_grammar.tuple_val(&tuple_val_built)?;
        self.push(ASTType::TupleVal(tuple_val_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `TupleValOpt /* Option<T>::Some */: ConstValList CommaOpt^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val_opt_0(
        &mut self,
        _const_val_list: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val_list = pop_item!(self, const_val_list, ConstValList, context);
        let tuple_val_opt_0_built = TupleValOpt { const_val_list };
        self.push(ASTType::TupleValOpt(Some(tuple_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `TupleValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `QualifiedVal: QualifiedIdent QualifiedValOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val(
        &mut self,
        _qualified_ident: &ParseTreeType<'t>,
        _qualified_val_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_val_opt = pop_item!(self, qualified_val_opt, QualifiedValOpt, context);
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let qualified_val_built = QualifiedVal {
            qualified_ident,
            qualified_val_opt,
        };
        // Calling user action here
        self.user_grammar.qualified_val(&qualified_val_built)?;
        self.push(ASTType::QualifiedVal(qualified_val_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `QualifiedValOpt /* Option<T>::Some */: StructOrTupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val_opt_0(&mut self, _struct_or_tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_or_tuple_val = pop_item!(self, struct_or_tuple_val, StructOrTupleVal, context);
        let qualified_val_opt_0_built = QualifiedValOpt {
            struct_or_tuple_val,
        };
        self.push(
            ASTType::QualifiedValOpt(Some(qualified_val_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `QualifiedValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::QualifiedValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `StructOrTupleVal: StructVal;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_or_tuple_val_0(&mut self, _struct_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_val = pop_item!(self, struct_val, StructVal, context);
        let struct_or_tuple_val_0_built = StructOrTupleValStructVal {
            struct_val: Box::new(struct_val),
        };
        let struct_or_tuple_val_0_built = StructOrTupleVal::StructVal(struct_or_tuple_val_0_built);
        // Calling user action here
        self.user_grammar
            .struct_or_tuple_val(&struct_or_tuple_val_0_built)?;
        self.push(
            ASTType::StructOrTupleVal(struct_or_tuple_val_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `StructOrTupleVal: TupleStructVal;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_or_tuple_val_1(&mut self, _tuple_struct_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_struct_val = pop_item!(self, tuple_struct_val, TupleStructVal, context);
        let struct_or_tuple_val_1_built = StructOrTupleValTupleStructVal { tuple_struct_val };
        let struct_or_tuple_val_1_built =
            StructOrTupleVal::TupleStructVal(struct_or_tuple_val_1_built);
        // Calling user action here
        self.user_grammar
            .struct_or_tuple_val(&struct_or_tuple_val_1_built)?;
        self.push(
            ASTType::StructOrTupleVal(struct_or_tuple_val_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `StructVal: LBrace^ /* Clipped */ StructValOpt /* Option */ RBrace^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _struct_val_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let struct_val_opt = pop_item!(self, struct_val_opt, StructValOpt, context);
        self.pop(context);
        let struct_val_built = StructVal { struct_val_opt };
        // Calling user action here
        self.user_grammar.struct_val(&struct_val_built)?;
        self.push(ASTType::StructVal(struct_val_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `StructValOpt /* Option<T>::Some */: MemberValues Comma^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val_opt_0(
        &mut self,
        _member_values: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let member_values = pop_item!(self, member_values, MemberValues, context);
        let struct_val_opt_0_built = StructValOpt { member_values };
        self.push(ASTType::StructValOpt(Some(struct_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `StructValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `MemberValues: MemberValue MemberValuesList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values(
        &mut self,
        _member_value: &ParseTreeType<'t>,
        _member_values_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let member_values_list =
            pop_and_reverse_item!(self, member_values_list, MemberValuesList, context);
        let member_value = pop_item!(self, member_value, MemberValue, context);
        let member_values_built = MemberValues {
            member_value,
            member_values_list,
        };
        // Calling user action here
        self.user_grammar.member_values(&member_values_built)?;
        self.push(ASTType::MemberValues(member_values_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `MemberValuesList /* Vec<T>::Push */: Comma^ /* Clipped */ MemberValue MemberValuesList;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _member_value: &ParseTreeType<'t>,
        _member_values_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut member_values_list = pop_item!(self, member_values_list, MemberValuesList, context);
        let member_value = pop_item!(self, member_value, MemberValue, context);
        self.pop(context);
        let member_values_list_0_built = MemberValuesList { member_value };
        // Add an element to the vector
        member_values_list.push(member_values_list_0_built);
        self.push(ASTType::MemberValuesList(member_values_list), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `MemberValuesList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let member_values_list_1_built = Vec::new();
        self.push(
            ASTType::MemberValuesList(member_values_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `MemberValue: Ident Colon^ /* Clipped */ ConstVal;`
    ///
    #[parol_runtime::function_name::named]
    fn member_value(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        let ident = pop_item!(self, ident, Ident, context);
        let member_value_built = MemberValue { ident, const_val };
        // Calling user action here
        self.user_grammar.member_value(&member_value_built)?;
        self.push(ASTType::MemberValue(member_value_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `TupleStructVal: TupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_struct_val(&mut self, _tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_val = pop_item!(self, tuple_val, TupleVal, context);
        let tuple_struct_val_built = TupleStructVal { tuple_val };
        // Calling user action here
        self.user_grammar
            .tuple_struct_val(&tuple_struct_val_built)?;
        self.push(ASTType::TupleStructVal(tuple_struct_val_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `TypeSpec: QualifiedIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_0(&mut self, _qualified_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let type_spec_0_built = TypeSpecQualifiedIdent { qualified_ident };
        let type_spec_0_built = TypeSpec::QualifiedIdent(type_spec_0_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_0_built)?;
        self.push(ASTType::TypeSpec(type_spec_0_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `TypeSpec: ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_1(&mut self, _array_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let type_spec_1_built = TypeSpecArrayType {
            array_type: Box::new(array_type),
        };
        let type_spec_1_built = TypeSpec::ArrayType(type_spec_1_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_1_built)?;
        self.push(ASTType::TypeSpec(type_spec_1_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `TypeSpec: TupleType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_2(&mut self, _tuple_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_type = pop_item!(self, tuple_type, TupleType, context);
        let type_spec_2_built = TypeSpecTupleType {
            tuple_type: Box::new(tuple_type),
        };
        let type_spec_2_built = TypeSpec::TupleType(type_spec_2_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_2_built)?;
        self.push(ASTType::TypeSpec(type_spec_2_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `TypeSpec: OptionType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_3(&mut self, _option_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let option_type = pop_item!(self, option_type, OptionType, context);
        let type_spec_3_built = TypeSpecOptionType {
            option_type: Box::new(option_type),
        };
        let type_spec_3_built = TypeSpec::OptionType(type_spec_3_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_3_built)?;
        self.push(ASTType::TypeSpec(type_spec_3_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `ArrayType: Ref LBracket ArrayTypeSpec RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type(
        &mut self,
        _ref: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _array_type_spec: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let array_type_spec = pop_item!(self, array_type_spec, ArrayTypeSpec, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let array_type_built = ArrayType {
            r#ref,
            l_bracket,
            array_type_spec,
            r_bracket,
        };
        // Calling user action here
        self.user_grammar.array_type(&array_type_built)?;
        self.push(ASTType::ArrayType(array_type_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `ArrayTypeSpec: ArrayTypeSpecOpt /* Option */ ArrayElementType Semicolon Number;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec(
        &mut self,
        _array_type_spec_opt: &ParseTreeType<'t>,
        _array_element_type: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _number: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let array_element_type = pop_item!(self, array_element_type, ArrayElementType, context);
        let array_type_spec_opt = pop_item!(self, array_type_spec_opt, ArrayTypeSpecOpt, context);
        let array_type_spec_built = ArrayTypeSpec {
            array_type_spec_opt,
            array_element_type,
            semicolon,
            number,
        };
        // Calling user action here
        self.user_grammar.array_type_spec(&array_type_spec_built)?;
        self.push(ASTType::ArrayTypeSpec(array_type_spec_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `ArrayTypeSpecOpt /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec_opt_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let array_type_spec_opt_0_built = ArrayTypeSpecOpt { r#ref };
        self.push(
            ASTType::ArrayTypeSpecOpt(Some(array_type_spec_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `ArrayTypeSpecOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayTypeSpecOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `ArrayElementType: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn array_element_type_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let array_element_type_0_built = ArrayElementTypeIdent { ident };
        let array_element_type_0_built = ArrayElementType::Ident(array_element_type_0_built);
        // Calling user action here
        self.user_grammar
            .array_element_type(&array_element_type_0_built)?;
        self.push(
            ASTType::ArrayElementType(array_element_type_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `ArrayElementType: Tuple;`
    ///
    #[parol_runtime::function_name::named]
    fn array_element_type_1(&mut self, _tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple = pop_item!(self, tuple, Tuple, context);
        let array_element_type_1_built = ArrayElementTypeTuple { tuple };
        let array_element_type_1_built = ArrayElementType::Tuple(array_element_type_1_built);
        // Calling user action here
        self.user_grammar
            .array_element_type(&array_element_type_1_built)?;
        self.push(
            ASTType::ArrayElementType(array_element_type_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `OptionType: 'Option' LT TypeSpec GT;`
    ///
    #[parol_runtime::function_name::named]
    fn option_type(
        &mut self,
        option: &ParseTreeType<'t>,
        _l_t: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _g_t: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let option = option.token()?.clone();
        let g_t = pop_item!(self, g_t, GT, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let l_t = pop_item!(self, l_t, LT, context);
        let option_type_built = OptionType {
            option,
            l_t,
            type_spec,
            g_t,
        };
        // Calling user action here
        self.user_grammar.option_type(&option_type_built)?;
        self.push(ASTType::OptionType(option_type_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `Tuple: LParen TupleItems CommaOpt RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let tuple_items = pop_item!(self, tuple_items, TupleItems, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_built = Tuple {
            l_paren,
            tuple_items,
            comma_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple(&tuple_built)?;
        self.push(ASTType::Tuple(tuple_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `TupleType: LParen TupleItems CommaOpt RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_type(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let tuple_items = pop_item!(self, tuple_items, TupleItems, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_type_built = TupleType {
            l_paren,
            tuple_items,
            comma_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple_type(&tuple_type_built)?;
        self.push(ASTType::TupleType(tuple_type_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `TupleItems: TupleItemsOpt /* Option */ TypeSpec TupleItemsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items(
        &mut self,
        _tuple_items_opt: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _tuple_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_items_list =
            pop_and_reverse_item!(self, tuple_items_list, TupleItemsList, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let tuple_items_opt = pop_item!(self, tuple_items_opt, TupleItemsOpt, context);
        let tuple_items_built = TupleItems {
            tuple_items_opt,
            type_spec,
            tuple_items_list,
        };
        // Calling user action here
        self.user_grammar.tuple_items(&tuple_items_built)?;
        self.push(ASTType::TupleItems(tuple_items_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `TupleItemsList /* Vec<T>::Push */: Comma TupleItemsOpt0 /* Option */ TypeSpec TupleItemsList;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _tuple_items_opt0: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _tuple_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut tuple_items_list = pop_item!(self, tuple_items_list, TupleItemsList, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let tuple_items_opt0 = pop_item!(self, tuple_items_opt0, TupleItemsOpt0, context);
        let comma = pop_item!(self, comma, Comma, context);
        let tuple_items_list_0_built = TupleItemsList {
            type_spec,
            tuple_items_opt0,
            comma,
        };
        // Add an element to the vector
        tuple_items_list.push(tuple_items_list_0_built);
        self.push(ASTType::TupleItemsList(tuple_items_list), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `TupleItemsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_items_list_1_built = Vec::new();
        self.push(ASTType::TupleItemsList(tuple_items_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `TupleItemsOpt0 /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt0_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let tuple_items_opt0_0_built = TupleItemsOpt0 { r#ref };
        self.push(
            ASTType::TupleItemsOpt0(Some(tuple_items_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `TupleItemsOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleItemsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `TupleItemsOpt /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let tuple_items_opt_0_built = TupleItemsOpt { r#ref };
        self.push(
            ASTType::TupleItemsOpt(Some(tuple_items_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `TupleItemsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleItemsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `Skip: /&\[Production; \d+\] = &\[[.\r\n]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn skip(&mut self, skip: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let skip = skip.token()?.clone();
        let skip_built = Skip { skip };
        // Calling user action here
        self.user_grammar.skip(&skip_built)?;
        self.push(ASTType::Skip(skip_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `CommaOpt: CommaOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt(&mut self, _comma_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_opt0 = pop_item!(self, comma_opt0, CommaOpt0, context);
        let comma_opt_built = CommaOpt { comma_opt0 };
        // Calling user action here
        self.user_grammar.comma_opt(&comma_opt_built)?;
        self.push(ASTType::CommaOpt(comma_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `CommaOpt0 /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let comma_opt0_0_built = CommaOpt0 { comma };
        self.push(ASTType::CommaOpt0(Some(comma_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `CommaOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommaOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `Assign: '=';`
    ///
    #[parol_runtime::function_name::named]
    fn assign(&mut self, assign: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign = assign.token()?.clone();
        let assign_built = Assign { assign };
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `Number: /-?\d+/;`
    ///
    #[parol_runtime::function_name::named]
    fn number(&mut self, number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = number.token()?.clone();
        let number_built = Number { number };
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `Ref: '&';`
    ///
    #[parol_runtime::function_name::named]
    fn r#ref(&mut self, r#ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = r#ref.token()?.clone();
        let r#ref_built = Ref { r#ref };
        // Calling user action here
        self.user_grammar.r#ref(&r#ref_built)?;
        self.push(ASTType::Ref(r#ref_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `Semicolon: ';';`
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(&mut self, semicolon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token()?.clone();
        let semicolon_built = Semicolon { semicolon };
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `Comma: ',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `String: QuotedString;`
    ///
    #[parol_runtime::function_name::named]
    fn string_0(&mut self, _quoted_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_string = pop_item!(self, quoted_string, QuotedString, context);
        let string_0_built = StringQuotedString { quoted_string };
        let string_0_built = String::QuotedString(string_0_built);
        // Calling user action here
        self.user_grammar.string(&string_0_built)?;
        self.push(ASTType::String(string_0_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `String: RawString;`
    ///
    #[parol_runtime::function_name::named]
    fn string_1(&mut self, _raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = pop_item!(self, raw_string, RawString, context);
        let string_1_built = StringRawString { raw_string };
        let string_1_built = String::RawString(string_1_built);
        // Calling user action here
        self.user_grammar.string(&string_1_built)?;
        self.push(ASTType::String(string_1_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `QuotedString: /r#{0, 3}".*"#{0, 3}/;`
    ///
    #[parol_runtime::function_name::named]
    fn quoted_string(&mut self, quoted_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_string = quoted_string.token()?.clone();
        let quoted_string_built = QuotedString { quoted_string };
        // Calling user action here
        self.user_grammar.quoted_string(&quoted_string_built)?;
        self.push(ASTType::QuotedString(quoted_string_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `RawString: /"(\\"|[^"])*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string(&mut self, raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = raw_string.token()?.clone();
        let raw_string_built = RawString { raw_string };
        // Calling user action here
        self.user_grammar.raw_string(&raw_string_built)?;
        self.push(ASTType::RawString(raw_string_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `Ident: /[a-zA-Z_][a-zA-Z0-9_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `DoubleColon: '::';`
    ///
    #[parol_runtime::function_name::named]
    fn double_colon(&mut self, double_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_colon = double_colon.token()?.clone();
        let double_colon_built = DoubleColon { double_colon };
        // Calling user action here
        self.user_grammar.double_colon(&double_colon_built)?;
        self.push(ASTType::DoubleColon(double_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `Colon: ':';`
    ///
    #[parol_runtime::function_name::named]
    fn colon(&mut self, colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token()?.clone();
        let colon_built = Colon { colon };
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `LBrace: '{';`
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(&mut self, l_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token()?.clone();
        let l_brace_built = LBrace { l_brace };
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `RBrace: '}';`
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(&mut self, r_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = r_brace.token()?.clone();
        let r_brace_built = RBrace { r_brace };
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `LBracket: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(&mut self, l_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token()?.clone();
        let l_bracket_built = LBracket { l_bracket };
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `RBracket: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(&mut self, r_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = r_bracket.token()?.clone();
        let r_bracket_built = RBracket { r_bracket };
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `LParen: '(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, l_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let l_paren_built = LParen { l_paren };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `RParen: ')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, r_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token()?.clone();
        let r_paren_built = RParen { r_paren };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `Hash: /#/;`
    ///
    #[parol_runtime::function_name::named]
    fn hash(&mut self, hash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token()?.clone();
        let hash_built = Hash { hash };
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `LT: '<';`
    ///
    #[parol_runtime::function_name::named]
    fn l_t(&mut self, l_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token()?.clone();
        let l_t_built = LT { l_t };
        // Calling user action here
        self.user_grammar.l_t(&l_t_built)?;
        self.push(ASTType::LT(l_t_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `GT: '>';`
    ///
    #[parol_runtime::function_name::named]
    fn g_t(&mut self, g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t.token()?.clone();
        let g_t_built = GT { g_t };
        // Calling user action here
        self.user_grammar.g_t(&g_t_built)?;
        self.push(ASTType::GT(g_t_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for LaDfa2DotGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item LaDfa2DotGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.la_dfa2_dot(&children[0]),
            1 => self.la_dfa2_dot_list_0(&children[0], &children[1], &children[2]),
            2 => self.la_dfa2_dot_list_1(),
            3 => self.attribute_opt(&children[0]),
            4 => self.attribute_opt0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            5 => self.attribute_opt0_1(),
            6 => self.attribute_arg_opt(&children[0]),
            7 => self.attribute_arg_opt0_0(&children[0], &children[1], &children[2]),
            8 => self.attribute_arg_opt0_1(),
            9 => self.item_0(&children[0]),
            10 => self.item_1(&children[0]),
            11 => self.use_statement(&children[0], &children[1], &children[2]),
            12 => self.qualified_ident(&children[0], &children[1]),
            13 => self.qualified_ident_list_0(&children[0], &children[1], &children[2]),
            14 => self.qualified_ident_list_1(),
            15 => self.scoped_qualified_ident(&children[0], &children[1]),
            16 => self.scoped_qualified_ident_opt_0(&children[0], &children[1]),
            17 => self.scoped_qualified_ident_opt_1(),
            18 => self.scoped_list(&children[0], &children[1], &children[2], &children[3]),
            19 => self.scoped_list_items(&children[0], &children[1]),
            20 => self.scoped_list_items_list_0(&children[0], &children[1], &children[2]),
            21 => self.scoped_list_items_list_1(),
            22 => self.const_declaration_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            23 => self.const_declaration_1(&children[0], &children[1]),
            24 => self.const_preamble(&children[0], &children[1], &children[2]),
            25 => self.const_qualifier_0(&children[0], &children[1]),
            26 => self.const_qualifier_1(&children[0]),
            27 => self.const_qualifier_opt_0(&children[0]),
            28 => self.const_qualifier_opt_1(),
            29 => self.const_name(&children[0]),
            30 => self.const_val_0(&children[0]),
            31 => self.const_val_1(&children[0]),
            32 => self.const_val_2(&children[0]),
            33 => self.const_val_3(&children[0]),
            34 => self.const_val_4(&children[0]),
            35 => self.array_val(&children[0], &children[1], &children[2], &children[3]),
            36 => self.array_val_opt_0(&children[0], &children[1]),
            37 => self.array_val_opt_1(),
            38 => self.const_val_list(&children[0], &children[1]),
            39 => self.const_val_list_list_0(&children[0], &children[1], &children[2]),
            40 => self.const_val_list_list_1(),
            41 => self.tuple_val(&children[0], &children[1], &children[2]),
            42 => self.tuple_val_opt_0(&children[0], &children[1]),
            43 => self.tuple_val_opt_1(),
            44 => self.qualified_val(&children[0], &children[1]),
            45 => self.qualified_val_opt_0(&children[0]),
            46 => self.qualified_val_opt_1(),
            47 => self.struct_or_tuple_val_0(&children[0]),
            48 => self.struct_or_tuple_val_1(&children[0]),
            49 => self.struct_val(&children[0], &children[1], &children[2]),
            50 => self.struct_val_opt_0(&children[0], &children[1]),
            51 => self.struct_val_opt_1(),
            52 => self.member_values(&children[0], &children[1]),
            53 => self.member_values_list_0(&children[0], &children[1], &children[2]),
            54 => self.member_values_list_1(),
            55 => self.member_value(&children[0], &children[1], &children[2]),
            56 => self.tuple_struct_val(&children[0]),
            57 => self.type_spec_0(&children[0]),
            58 => self.type_spec_1(&children[0]),
            59 => self.type_spec_2(&children[0]),
            60 => self.type_spec_3(&children[0]),
            61 => self.array_type(&children[0], &children[1], &children[2], &children[3]),
            62 => self.array_type_spec(&children[0], &children[1], &children[2], &children[3]),
            63 => self.array_type_spec_opt_0(&children[0]),
            64 => self.array_type_spec_opt_1(),
            65 => self.array_element_type_0(&children[0]),
            66 => self.array_element_type_1(&children[0]),
            67 => self.option_type(&children[0], &children[1], &children[2], &children[3]),
            68 => self.tuple(&children[0], &children[1], &children[2], &children[3]),
            69 => self.tuple_type(&children[0], &children[1], &children[2], &children[3]),
            70 => self.tuple_items(&children[0], &children[1], &children[2]),
            71 => self.tuple_items_list_0(&children[0], &children[1], &children[2], &children[3]),
            72 => self.tuple_items_list_1(),
            73 => self.tuple_items_opt0_0(&children[0]),
            74 => self.tuple_items_opt0_1(),
            75 => self.tuple_items_opt_0(&children[0]),
            76 => self.tuple_items_opt_1(),
            77 => self.skip(&children[0]),
            78 => self.comma_opt(&children[0]),
            79 => self.comma_opt0_0(&children[0]),
            80 => self.comma_opt0_1(),
            81 => self.assign(&children[0]),
            82 => self.number(&children[0]),
            83 => self.r#ref(&children[0]),
            84 => self.semicolon(&children[0]),
            85 => self.comma(&children[0]),
            86 => self.string_0(&children[0]),
            87 => self.string_1(&children[0]),
            88 => self.quoted_string(&children[0]),
            89 => self.raw_string(&children[0]),
            90 => self.ident(&children[0]),
            91 => self.double_colon(&children[0]),
            92 => self.colon(&children[0]),
            93 => self.l_brace(&children[0]),
            94 => self.r_brace(&children[0]),
            95 => self.l_bracket(&children[0]),
            96 => self.r_bracket(&children[0]),
            97 => self.l_paren(&children[0]),
            98 => self.r_paren(&children[0]),
            99 => self.hash(&children[0]),
            100 => self.l_t(&children[0]),
            101 => self.g_t(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
