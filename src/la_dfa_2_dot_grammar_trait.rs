// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait LaDfa2DotGrammarTrait<'t> {
    /// Semantic action for non-terminal 'LaDfa2Dot'
    fn la_dfa2_dot(&mut self, _arg: &LaDfa2Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parts'
    fn parts(&mut self, _arg: &Parts<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NamingComment'
    fn naming_comment(&mut self, _arg: &NamingComment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prod0'
    fn prod0(&mut self, _arg: &Prod0<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Transitions'
    fn transitions(&mut self, _arg: &Transitions<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransList'
    fn trans_list(&mut self, _arg: &TransList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntry'
    fn trans_entry(&mut self, _arg: &TransEntry<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'K'
    fn k(&mut self, _arg: &K<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProdNum'
    fn prod_num(&mut self, _arg: &ProdNum<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NtName'
    fn nt_name(&mut self, _arg: &NtName<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dash'
    fn dash(&mut self, _arg: &Dash<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Dash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dash<'t> {
    pub dash: Token<'t>, /* - */
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* -?\d+ */
}

///
/// Type derived for non-terminal K
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct K<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal LaDfa2Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LaDfa2Dot<'t> {
    pub naming_comment: Box<NamingComment<'t>>,
    pub parts: Box<Parts<'t>>,
}

///
/// Type derived for non-terminal NamingComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NamingComment<'t> {
    pub prod_num: Box<ProdNum<'t>>,
    pub nt_name: Box<NtName<'t>>,
}

///
/// Type derived for non-terminal NtName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NtName<'t> {
    pub nt_name: Token<'t>, /* "\w+?" */
}

///
/// Type derived for non-terminal Parts
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parts<'t> {
    pub prod0: Box<Prod0<'t>>,
    pub transitions: Box<Transitions<'t>>,
    pub k: Box<K<'t>>,
    pub parts_opt: Option<Box<PartsOpt>>,
}

///
/// Type derived for non-terminal PartsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PartsOpt {}

///
/// Type derived for non-terminal Prod0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prod0<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal ProdNum
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProdNum<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal TransEntry
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntry<'t> {
    pub integer: Box<Integer<'t>>,
    pub integer0: Box<Integer<'t>>,
    pub integer1: Box<Integer<'t>>,
    pub integer2: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal TransList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransList<'t> {
    pub trans_list_list: Vec<TransListList<'t>>,
}

///
/// Type derived for non-terminal TransListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransListList<'t> {
    pub trans_entry: Box<TransEntry<'t>>,
}

///
/// Type derived for non-terminal Transitions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Transitions<'t> {
    pub trans_list: Box<TransList<'t>>,
    pub transitions_opt: Option<Box<TransitionsOpt>>,
}

///
/// Type derived for non-terminal TransitionsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransitionsOpt {}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Dash(Dash<'t>),
    Integer(Integer<'t>),
    K(K<'t>),
    LaDfa2Dot(LaDfa2Dot<'t>),
    NamingComment(NamingComment<'t>),
    NtName(NtName<'t>),
    Parts(Parts<'t>),
    PartsOpt(Option<Box<PartsOpt>>),
    Prod0(Prod0<'t>),
    ProdNum(ProdNum<'t>),
    TransEntry(TransEntry<'t>),
    TransList(TransList<'t>),
    TransListList(Vec<TransListList<'t>>),
    Transitions(Transitions<'t>),
    TransitionsOpt(Option<Box<TransitionsOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct LaDfa2DotGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `LaDfa2DotGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> LaDfa2DotGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// LaDfa2Dot: NamingComment 'LookaheadDFA'^ /* Clipped */ Parts;
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot(
        &mut self,
        _naming_comment: &ParseTreeType<'t>,
        _lookahead_d_f_a: &ParseTreeType<'t>,
        _parts: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts = pop_item!(self, parts, Parts, context);
        let naming_comment = pop_item!(self, naming_comment, NamingComment, context);
        let la_dfa2_dot_built = LaDfa2Dot {
            naming_comment: Box::new(naming_comment),
            // Ignore clipped member 'lookahead_d_f_a'
            parts: Box::new(parts),
        };
        // Calling user action here
        self.user_grammar.la_dfa2_dot(&la_dfa2_dot_built)?;
        self.push(ASTType::LaDfa2Dot(la_dfa2_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Parts: '{'^ /* Clipped */ Prod0 Transitions K '}'^ /* Clipped */ PartsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn parts(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _prod0: &ParseTreeType<'t>,
        _transitions: &ParseTreeType<'t>,
        _k: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _parts_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts_opt = pop_item!(self, parts_opt, PartsOpt, context);
        let k = pop_item!(self, k, K, context);
        let transitions = pop_item!(self, transitions, Transitions, context);
        let prod0 = pop_item!(self, prod0, Prod0, context);
        let parts_built = Parts {
            // Ignore clipped member 'l_brace'
            prod0: Box::new(prod0),
            transitions: Box::new(transitions),
            k: Box::new(k),
            // Ignore clipped member 'r_brace'
            parts_opt,
        };
        // Calling user action here
        self.user_grammar.parts(&parts_built)?;
        self.push(ASTType::Parts(parts_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// PartsOpt /* `Option<T>::Some` */: ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn parts_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts_opt_0_built = PartsOpt {
        // Ignore clipped member 'comma'
        };
        self.push(
            ASTType::PartsOpt(Some(Box::new(parts_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// PartsOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn parts_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PartsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// NamingComment: '/'^ /* Clipped */ '*'^ /* Clipped */ ProdNum Dash^ /* Clipped */ NtName '*'^ /* Clipped */ '/'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn naming_comment(
        &mut self,
        _slash: &ParseTreeType<'t>,
        _star: &ParseTreeType<'t>,
        _prod_num: &ParseTreeType<'t>,
        _dash: &ParseTreeType<'t>,
        _nt_name: &ParseTreeType<'t>,
        _star0: &ParseTreeType<'t>,
        _slash0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nt_name = pop_item!(self, nt_name, NtName, context);
        // Ignore clipped member 'dash'
        self.pop(context);
        let prod_num = pop_item!(self, prod_num, ProdNum, context);
        let naming_comment_built = NamingComment {
            // Ignore clipped member 'slash'
            // Ignore clipped member 'star'
            prod_num: Box::new(prod_num),
            // Ignore clipped member 'dash'
            nt_name: Box::new(nt_name),
            // Ignore clipped member 'star0'
            // Ignore clipped member 'slash0'
        };
        // Calling user action here
        self.user_grammar.naming_comment(&naming_comment_built)?;
        self.push(ASTType::NamingComment(naming_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Prod0: 'prod0'^ /* Clipped */ ':'^ /* Clipped */ Integer ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn prod0(
        &mut self,
        _prod0: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let prod0_built = Prod0 {
            // Ignore clipped member 'prod0'
            // Ignore clipped member 'colon'
            integer: Box::new(integer),
            // Ignore clipped member 'comma'
        };
        // Calling user action here
        self.user_grammar.prod0(&prod0_built)?;
        self.push(ASTType::Prod0(prod0_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Transitions: 'transitions'^ /* Clipped */ ':'^ /* Clipped */ '&'^ /* Clipped */ '['^ /* Clipped */ TransList ']'^ /* Clipped */ TransitionsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions(
        &mut self,
        _transitions: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _amp: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _trans_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
        _transitions_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let transitions_opt = pop_item!(self, transitions_opt, TransitionsOpt, context);
        let trans_list = pop_item!(self, trans_list, TransList, context);
        let transitions_built = Transitions {
            // Ignore clipped member 'transitions'
            // Ignore clipped member 'colon'
            // Ignore clipped member 'amp'
            // Ignore clipped member 'l_bracket'
            trans_list: Box::new(trans_list),
            // Ignore clipped member 'r_bracket'
            transitions_opt,
        };
        // Calling user action here
        self.user_grammar.transitions(&transitions_built)?;
        self.push(ASTType::Transitions(transitions_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// TransitionsOpt /* `Option<T>::Some` */: ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let transitions_opt_0_built = TransitionsOpt {
        // Ignore clipped member 'comma'
        };
        self.push(
            ASTType::TransitionsOpt(Some(Box::new(transitions_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// TransitionsOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TransitionsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// TransList: TransListList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list(&mut self, _trans_list_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list = pop_and_reverse_item!(self, trans_list_list, TransListList, context);
        let trans_list_built = TransList { trans_list_list };
        // Calling user action here
        self.user_grammar.trans_list(&trans_list_built)?;
        self.push(ASTType::TransList(trans_list_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// TransListList /* `Vec<T>::Push` */: TransEntry TransListList;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_0(
        &mut self,
        _trans_entry: &ParseTreeType<'t>,
        _trans_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut trans_list_list = pop_item!(self, trans_list_list, TransListList, context);
        let trans_entry = pop_item!(self, trans_entry, TransEntry, context);
        let trans_list_list_0_built = TransListList {
            trans_entry: Box::new(trans_entry),
        };
        // Add an element to the vector
        trans_list_list.push(trans_list_list_0_built);
        self.push(ASTType::TransListList(trans_list_list), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// TransListList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list_1_built = Vec::new();
        self.push(ASTType::TransListList(trans_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// TransEntry: 'Trans'^ /* Clipped */ '('^ /* Clipped */ Integer ','^ /* Clipped */ Integer ','^ /* Clipped */ Integer ','^ /* Clipped */ Integer ')'^ /* Clipped */ ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry(
        &mut self,
        _trans: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _integer0: &ParseTreeType<'t>,
        _comma0: &ParseTreeType<'t>,
        _integer1: &ParseTreeType<'t>,
        _comma1: &ParseTreeType<'t>,
        _integer2: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _comma2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer2 = pop_item!(self, integer2, Integer, context);
        let integer1 = pop_item!(self, integer1, Integer, context);
        let integer0 = pop_item!(self, integer0, Integer, context);
        let integer = pop_item!(self, integer, Integer, context);
        let trans_entry_built = TransEntry {
            // Ignore clipped member 'trans'
            // Ignore clipped member 'l_paren'
            integer: Box::new(integer),
            // Ignore clipped member 'comma'
            integer0: Box::new(integer0),
            // Ignore clipped member 'comma0'
            integer1: Box::new(integer1),
            // Ignore clipped member 'comma1'
            integer2: Box::new(integer2),
            // Ignore clipped member 'r_paren'
            // Ignore clipped member 'comma2'
        };
        // Calling user action here
        self.user_grammar.trans_entry(&trans_entry_built)?;
        self.push(ASTType::TransEntry(trans_entry_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// K: 'k'^ /* Clipped */ ':'^ /* Clipped */ Integer ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn k(
        &mut self,
        _k: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let k_built = K {
            // Ignore clipped member 'k'
            // Ignore clipped member 'colon'
            integer: Box::new(integer),
            // Ignore clipped member 'comma'
        };
        // Calling user action here
        self.user_grammar.k(&k_built)?;
        self.push(ASTType::K(k_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// ProdNum: Integer;
    ///
    #[parol_runtime::function_name::named]
    fn prod_num(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let prod_num_built = ProdNum {
            integer: Box::new(integer),
        };
        // Calling user action here
        self.user_grammar.prod_num(&prod_num_built)?;
        self.push(ASTType::ProdNum(prod_num_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// NtName: /"\w+?"/;
    ///
    #[parol_runtime::function_name::named]
    fn nt_name(&mut self, nt_name: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nt_name = nt_name.token()?.clone();
        let nt_name_built = NtName { nt_name };
        // Calling user action here
        self.user_grammar.nt_name(&nt_name_built)?;
        self.push(ASTType::NtName(nt_name_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Integer: /-?\d+/;
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Dash: '-';
    ///
    #[parol_runtime::function_name::named]
    fn dash(&mut self, dash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dash = dash.token()?.clone();
        let dash_built = Dash { dash };
        // Calling user action here
        self.user_grammar.dash(&dash_built)?;
        self.push(ASTType::Dash(dash_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for LaDfa2DotGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item LaDfa2DotGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.la_dfa2_dot(&children[0], &children[1], &children[2]),
            1 => self.parts(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            2 => self.parts_opt_0(&children[0]),
            3 => self.parts_opt_1(),
            4 => self.naming_comment(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            5 => self.prod0(&children[0], &children[1], &children[2], &children[3]),
            6 => self.transitions(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            7 => self.transitions_opt_0(&children[0]),
            8 => self.transitions_opt_1(),
            9 => self.trans_list(&children[0]),
            10 => self.trans_list_list_0(&children[0], &children[1]),
            11 => self.trans_list_list_1(),
            12 => self.trans_entry(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
            ),
            13 => self.k(&children[0], &children[1], &children[2], &children[3]),
            14 => self.prod_num(&children[0]),
            15 => self.nt_name(&children[0]),
            16 => self.integer(&children[0]),
            17 => self.dash(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
}
