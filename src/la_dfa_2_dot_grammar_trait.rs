// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait LaDfa2DotGrammarTrait<'t> {
    /// Semantic action for non-terminal 'LaDfa2Dot'
    fn la_dfa2_dot(&mut self, _arg: &LaDfa2Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeOpt'
    fn attribute_opt(&mut self, _arg: &AttributeOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeArgOpt'
    fn attribute_arg_opt(&mut self, _arg: &AttributeArgOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Item'
    fn item(&mut self, _arg: &Item<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UseStatement'
    fn use_statement(&mut self, _arg: &UseStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualifiedIdent'
    fn qualified_ident(&mut self, _arg: &QualifiedIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedQualifiedIdent'
    fn scoped_qualified_ident(&mut self, _arg: &ScopedQualifiedIdent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedList'
    fn scoped_list(&mut self, _arg: &ScopedList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedListItems'
    fn scoped_list_items(&mut self, _arg: &ScopedListItems<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDeclaration'
    fn const_declaration(&mut self, _arg: &ConstDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstPreamble'
    fn const_preamble(&mut self, _arg: &ConstPreamble<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstQualifier'
    fn const_qualifier(&mut self, _arg: &ConstQualifier<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstName'
    fn const_name(&mut self, _arg: &ConstName<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstVal'
    fn const_val(&mut self, _arg: &ConstVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayVal'
    fn array_val(&mut self, _arg: &ArrayVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstValList'
    fn const_val_list(&mut self, _arg: &ConstValList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleVal'
    fn tuple_val(&mut self, _arg: &TupleVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QualifiedVal'
    fn qualified_val(&mut self, _arg: &QualifiedVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructOrTupleVal'
    fn struct_or_tuple_val(&mut self, _arg: &StructOrTupleVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructVal'
    fn struct_val(&mut self, _arg: &StructVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MemberValues'
    fn member_values(&mut self, _arg: &MemberValues<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MemberValue'
    fn member_value(&mut self, _arg: &MemberValue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleStructVal'
    fn tuple_struct_val(&mut self, _arg: &TupleStructVal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerMacro'
    fn scanner_macro(&mut self, _arg: &ScannerMacro<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerMacroBody'
    fn scanner_macro_body(&mut self, _arg: &ScannerMacroBody) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScannerMacroItem'
    fn scanner_macro_item(&mut self, _arg: &ScannerMacroItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TokenDefinition'
    fn token_definition(&mut self, _arg: &TokenDefinition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModeTransition'
    fn mode_transition(&mut self, _arg: &ModeTransition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LookaheadExpression'
    fn lookahead_expression(&mut self, _arg: &LookaheadExpression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeSpec'
    fn type_spec(&mut self, _arg: &TypeSpec<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayType'
    fn array_type(&mut self, _arg: &ArrayType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayTypeSpec'
    fn array_type_spec(&mut self, _arg: &ArrayTypeSpec<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayElementType'
    fn array_element_type(&mut self, _arg: &ArrayElementType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OptionType'
    fn option_type(&mut self, _arg: &OptionType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tuple'
    fn tuple(&mut self, _arg: &Tuple<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleType'
    fn tuple_type(&mut self, _arg: &TupleType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TupleItems'
    fn tuple_items(&mut self, _arg: &TupleItems<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Skip'
    fn skip(&mut self, _arg: &Skip<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaOpt'
    fn comma_opt(&mut self, _arg: &CommaOpt<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ref'
    fn r#ref(&mut self, _arg: &Ref<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Arrow'
    fn arrow(&mut self, _arg: &Arrow<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuotedString'
    fn quoted_string(&mut self, _arg: &QuotedString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawStringStart'
    fn raw_string_start(&mut self, _arg: &RawStringStart<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawStringEnd'
    fn raw_string_end(&mut self, _arg: &RawStringEnd<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawStringContent'
    fn raw_string_content(&mut self, _arg: &RawStringContent<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString'
    fn raw_string(&mut self, _arg: &RawString<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString1Start'
    fn raw_string1_start(&mut self, _arg: &RawString1Start<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString1End'
    fn raw_string1_end(&mut self, _arg: &RawString1End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawStringContentNoQuotes'
    fn raw_string_content_no_quotes(&mut self, _arg: &RawStringContentNoQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString1ContentQuotes'
    fn raw_string1_content_quotes(&mut self, _arg: &RawString1ContentQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString1Content'
    fn raw_string1_content(&mut self, _arg: &RawString1Content<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString1'
    fn raw_string1(&mut self, _arg: &RawString1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString2Start'
    fn raw_string2_start(&mut self, _arg: &RawString2Start<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString2End'
    fn raw_string2_end(&mut self, _arg: &RawString2End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString2ContentQuotes'
    fn raw_string2_content_quotes(&mut self, _arg: &RawString2ContentQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString2Content'
    fn raw_string2_content(&mut self, _arg: &RawString2Content<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString2'
    fn raw_string2(&mut self, _arg: &RawString2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString3Start'
    fn raw_string3_start(&mut self, _arg: &RawString3Start<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString3End'
    fn raw_string3_end(&mut self, _arg: &RawString3End<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString3ContentQuotes'
    fn raw_string3_content_quotes(&mut self, _arg: &RawString3ContentQuotes<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString3Content'
    fn raw_string3_content(&mut self, _arg: &RawString3Content<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RawString3'
    fn raw_string3(&mut self, _arg: &RawString3<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ident'
    fn ident(&mut self, _arg: &Ident<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DoubleColon'
    fn double_colon(&mut self, _arg: &DoubleColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LT'
    fn l_t(&mut self, _arg: &LT<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GT'
    fn g_t(&mut self, _arg: &GT<'t>) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'t>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 9
///
/// `Item: UseStatement^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ItemUseStatement {}

///
/// Type derived for production 10
///
/// `Item: ConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ItemConstDeclaration<'t> {
    pub const_declaration: ConstDeclaration<'t>,
}

///
/// Type derived for production 11
///
/// `Item: ScannerMacro;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ItemScannerMacro<'t> {
    pub scanner_macro: ScannerMacro<'t>,
}

///
/// Type derived for production 23
///
/// `ConstDeclaration: ConstPreamble TypeSpec^ /* Clipped */ Assign^ /* Clipped */ ConstVal Semicolon^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon<'t> {
    pub const_preamble: ConstPreamble<'t>,
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for production 24
///
/// `ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstDeclarationConstPreambleSkip {}

///
/// Type derived for production 26
///
/// `ConstQualifier: ConstQualifierOpt /* Option */ 'const';`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstQualifierConstQualifierOptConst<'t> {
    pub const_qualifier_opt: Option<ConstQualifierOpt<'t>>,
    pub r#const: Token<'t>, /* const */
}

///
/// Type derived for production 27
///
/// `ConstQualifier: 'static';`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstQualifierStatic<'t> {
    pub r#static: Token<'t>, /* static */
}

///
/// Type derived for production 31
///
/// `ConstVal: Number;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValNumber<'t> {
    pub number: Number<'t>,
}

///
/// Type derived for production 32
///
/// `ConstVal: String;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValString<'t> {
    pub string: String<'t>,
}

///
/// Type derived for production 33
///
/// `ConstVal: QualifiedVal;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValQualifiedVal<'t> {
    pub qualified_val: Box<QualifiedVal<'t>>,
}

///
/// Type derived for production 34
///
/// `ConstVal: ArrayVal;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValArrayVal<'t> {
    pub array_val: Box<ArrayVal<'t>>,
}

///
/// Type derived for production 35
///
/// `ConstVal: TupleVal;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValTupleVal<'t> {
    pub tuple_val: Box<TupleVal<'t>>,
}

///
/// Type derived for production 48
///
/// `StructOrTupleVal: StructVal;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructOrTupleValStructVal<'t> {
    pub struct_val: StructVal<'t>,
}

///
/// Type derived for production 49
///
/// `StructOrTupleVal: TupleStructVal;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructOrTupleValTupleStructVal<'t> {
    pub tuple_struct_val: TupleStructVal<'t>,
}

///
/// Type derived for production 64
///
/// `ScannerMacroItemListGroup: TokenDefinition^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroItemListGroupTokenDefinition {}

///
/// Type derived for production 65
///
/// `ScannerMacroItemListGroup: ModeTransition^ /* Clipped */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroItemListGroupModeTransition {}

///
/// Type derived for production 74
///
/// `TypeSpec: QualifiedIdent;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeSpecQualifiedIdent<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
}

///
/// Type derived for production 75
///
/// `TypeSpec: ArrayType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeSpecArrayType<'t> {
    pub array_type: Box<ArrayType<'t>>,
}

///
/// Type derived for production 76
///
/// `TypeSpec: TupleType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeSpecTupleType<'t> {
    pub tuple_type: Box<TupleType<'t>>,
}

///
/// Type derived for production 77
///
/// `TypeSpec: OptionType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeSpecOptionType<'t> {
    pub option_type: Box<OptionType<'t>>,
}

///
/// Type derived for production 82
///
/// `ArrayElementType: Ident;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementTypeIdent<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for production 83
///
/// `ArrayElementType: Tuple;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayElementTypeTuple<'t> {
    pub tuple: Tuple<'t>,
}

///
/// Type derived for production 104
///
/// `String: QuotedString;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringQuotedString<'t> {
    pub quoted_string: QuotedString<'t>,
}

///
/// Type derived for production 105
///
/// `String: RawString;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringRawString<'t> {
    pub raw_string: RawString<'t>,
}

///
/// Type derived for production 106
///
/// `String: RawString1;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringRawString1<'t> {
    pub raw_string1: RawString1<'t>,
}

///
/// Type derived for production 107
///
/// `String: RawString2;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringRawString2<'t> {
    pub raw_string2: RawString2<'t>,
}

///
/// Type derived for production 108
///
/// `String: RawString3;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringRawString3<'t> {
    pub raw_string3: RawString3<'t>,
}

///
/// Type derived for production 120
///
/// `RawString1ContentListGroup: RawStringContentNoQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1ContentListGroupRawStringContentNoQuotes<'t> {
    pub raw_string_content_no_quotes: RawStringContentNoQuotes<'t>,
}

///
/// Type derived for production 121
///
/// `RawString1ContentListGroup: RawString1ContentQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1ContentListGroupRawString1ContentQuotes<'t> {
    pub raw_string1_content_quotes: RawString1ContentQuotes<'t>,
}

///
/// Type derived for production 129
///
/// `RawString2ContentListGroup: RawStringContentNoQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2ContentListGroupRawStringContentNoQuotes<'t> {
    pub raw_string_content_no_quotes: RawStringContentNoQuotes<'t>,
}

///
/// Type derived for production 130
///
/// `RawString2ContentListGroup: RawString2ContentQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2ContentListGroupRawString2ContentQuotes<'t> {
    pub raw_string2_content_quotes: RawString2ContentQuotes<'t>,
}

///
/// Type derived for production 138
///
/// `RawString3ContentListGroup: RawStringContentNoQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3ContentListGroupRawStringContentNoQuotes<'t> {
    pub raw_string_content_no_quotes: RawStringContentNoQuotes<'t>,
}

///
/// Type derived for production 139
///
/// `RawString3ContentListGroup: RawString3ContentQuotes;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3ContentListGroupRawString3ContentQuotes<'t> {
    pub raw_string3_content_quotes: RawString3ContentQuotes<'t>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ArrayElementType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayElementType<'t> {
    Ident(ArrayElementTypeIdent<'t>),
    Tuple(ArrayElementTypeTuple<'t>),
}

///
/// Type derived for non-terminal ArrayType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayType<'t> {
    pub r#ref: Ref<'t>,
    pub l_bracket: LBracket<'t>,
    pub array_type_spec: ArrayTypeSpec<'t>,
    pub r_bracket: RBracket<'t>,
}

///
/// Type derived for non-terminal ArrayTypeSpec
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayTypeSpec<'t> {
    pub array_type_spec_opt: Option<ArrayTypeSpecOpt<'t>>,
    pub array_element_type: ArrayElementType<'t>,
    pub semicolon: Semicolon<'t>,
    pub number: Number<'t>,
}

///
/// Type derived for non-terminal ArrayTypeSpecOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayTypeSpecOpt<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal ArrayVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayVal<'t> {
    pub array_val_opt: Option<ArrayValOpt<'t>>,
}

///
/// Type derived for non-terminal ArrayValOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayValOpt<'t> {
    pub const_val_list: ConstValList<'t>,
}

///
/// Type derived for non-terminal Arrow
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Arrow<'t> {
    pub arrow: Token<'t>, /* => */
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Assign<'t> {
    pub assign: Token<'t>, /* = */
}

///
/// Type derived for non-terminal AttributeArgOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeArgOpt<'t> {
    pub attribute_arg_opt0: Option<AttributeArgOpt0<'t>>,
}

///
/// Type derived for non-terminal AttributeArgOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeArgOpt0<'t> {
    pub l_paren: LParen<'t>,
    pub ident: Ident<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal AttributeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeOpt<'t> {
    pub attribute_opt0: Option<AttributeOpt0<'t>>,
}

///
/// Type derived for non-terminal AttributeOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeOpt0<'t> {
    pub hash: Hash<'t>,
    pub l_bracket: LBracket<'t>,
    pub ident: Ident<'t>,
    pub attribute_arg_opt: AttributeArgOpt<'t>,
    pub r_bracket: RBracket<'t>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Colon<'t> {
    pub colon: Token<'t>, /* : */
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal CommaOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommaOpt<'t> {
    pub comma_opt0: Option<CommaOpt0<'t>>,
}

///
/// Type derived for non-terminal CommaOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommaOpt0<'t> {
    pub comma: Comma<'t>,
}

///
/// Type derived for non-terminal ConstDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstDeclaration<'t> {
    ConstPreambleTypeSpecAssignConstValSemicolon(
        ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon<'t>,
    ),
    ConstPreambleSkip(ConstDeclarationConstPreambleSkip),
}

///
/// Type derived for non-terminal ConstName
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstName<'t> {
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal ConstPreamble
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstPreamble<'t> {
    pub const_name: ConstName<'t>,
}

///
/// Type derived for non-terminal ConstQualifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstQualifier<'t> {
    ConstQualifierOptConst(ConstQualifierConstQualifierOptConst<'t>),
    Static(ConstQualifierStatic<'t>),
}

///
/// Type derived for non-terminal ConstQualifierOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstQualifierOpt<'t> {
    pub r#pub: Token<'t>, /* pub */
}

///
/// Type derived for non-terminal ConstVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstVal<'t> {
    Number(ConstValNumber<'t>),
    String(ConstValString<'t>),
    QualifiedVal(ConstValQualifiedVal<'t>),
    ArrayVal(ConstValArrayVal<'t>),
    TupleVal(ConstValTupleVal<'t>),
}

///
/// Type derived for non-terminal ConstValList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValList<'t> {
    pub const_val: ConstVal<'t>,
    pub const_val_list_list: Vec<ConstValListList<'t>>,
}

///
/// Type derived for non-terminal ConstValListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstValListList<'t> {
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for non-terminal DoubleColon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DoubleColon<'t> {
    pub double_colon: Token<'t>, /* :: */
}

///
/// Type derived for non-terminal GT
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GT<'t> {
    pub g_t: Token<'t>, /* > */
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Hash<'t> {
    pub hash: Token<'t>, /* # */
}

///
/// Type derived for non-terminal Ident
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ident<'t> {
    pub ident: Token<'t>, /* [a-zA-Z_][a-zA-Z0-9_]* */
}

///
/// Type derived for non-terminal Item
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Item<'t> {
    UseStatement(ItemUseStatement),
    ConstDeclaration(ItemConstDeclaration<'t>),
    ScannerMacro(ItemScannerMacro<'t>),
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBrace<'t> {
    pub l_brace: Token<'t>, /* { */
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBracket<'t> {
    pub l_bracket: Token<'t>, /* [ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal LT
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LT<'t> {
    pub l_t: Token<'t>, /* < */
}

///
/// Type derived for non-terminal LaDfa2Dot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LaDfa2Dot<'t> {
    pub la_dfa2_dot_list: Vec<LaDfa2DotList<'t>>,
}

///
/// Type derived for non-terminal LaDfa2DotList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LaDfa2DotList<'t> {
    pub item: Item<'t>,
}

///
/// Type derived for non-terminal LookaheadExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LookaheadExpression<'t> {
    pub lookahead_expression_opt: Option<LookaheadExpressionOpt<'t>>,
}

///
/// Type derived for non-terminal LookaheadExpressionOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LookaheadExpressionOpt<'t> {
    pub not: Token<'t>, /* not */
}

///
/// Type derived for non-terminal MemberValue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MemberValue<'t> {
    pub ident: Ident<'t>,
    pub const_val: ConstVal<'t>,
}

///
/// Type derived for non-terminal MemberValues
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MemberValues<'t> {
    pub member_value: MemberValue<'t>,
    pub member_values_list: Vec<MemberValuesList<'t>>,
}

///
/// Type derived for non-terminal MemberValuesList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MemberValuesList<'t> {
    pub member_value: MemberValue<'t>,
}

///
/// Type derived for non-terminal ModeTransition
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModeTransition {}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Number<'t> {
    pub number: Token<'t>, /* -?\d+ */
}

///
/// Type derived for non-terminal OptionType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OptionType<'t> {
    pub option: Token<'t>, /* Option */
    pub l_t: LT<'t>,
    pub type_spec: TypeSpec<'t>,
    pub g_t: GT<'t>,
}

///
/// Type derived for non-terminal QualifiedIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QualifiedIdent<'t> {
    pub ident: Ident<'t>,
    pub qualified_ident_list: Vec<QualifiedIdentList<'t>>,
}

///
/// Type derived for non-terminal QualifiedIdentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QualifiedIdentList<'t> {
    pub double_colon: DoubleColon<'t>,
    pub ident: Ident<'t>,
}

///
/// Type derived for non-terminal QualifiedVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QualifiedVal<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
    pub qualified_val_opt: Option<QualifiedValOpt<'t>>,
}

///
/// Type derived for non-terminal QualifiedValOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QualifiedValOpt<'t> {
    pub struct_or_tuple_val: StructOrTupleVal<'t>,
}

///
/// Type derived for non-terminal QuotedString
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuotedString<'t> {
    pub quoted_string: Token<'t>, /* "([^"]|\\")*" */
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBrace<'t> {
    pub r_brace: Token<'t>, /* } */
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBracket<'t> {
    pub r_bracket: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal RawString
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString<'t> {
    pub strng: RawStringContent<'t>,
}

///
/// Type derived for non-terminal RawString1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1<'t> {
    pub strng: RawString1Content<'t>,
}

///
/// Type derived for non-terminal RawString1Content
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1Content<'t> {
    pub raw_string1_content_list: Vec<RawString1ContentList<'t>>,
}

///
/// Type derived for non-terminal RawString1ContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1ContentList<'t> {
    pub raw_string1_content_list_group: RawString1ContentListGroup<'t>,
}

///
/// Type derived for non-terminal RawString1ContentListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RawString1ContentListGroup<'t> {
    RawStringContentNoQuotes(RawString1ContentListGroupRawStringContentNoQuotes<'t>),
    RawString1ContentQuotes(RawString1ContentListGroupRawString1ContentQuotes<'t>),
}

///
/// Type derived for non-terminal RawString1ContentQuotes
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1ContentQuotes<'t> {
    pub raw_string_end: Token<'t>, /* " */
}

///
/// Type derived for non-terminal RawString1End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1End<'t> {
    pub raw_string1_end: Token<'t>, /* "# */
}

///
/// Type derived for non-terminal RawString1Start
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString1Start<'t> {
    pub raw_string1_start: Token<'t>, /* r#" */
}

///
/// Type derived for non-terminal RawString2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2<'t> {
    pub strng: RawString2Content<'t>,
}

///
/// Type derived for non-terminal RawString2Content
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2Content<'t> {
    pub raw_string2_content_list: Vec<RawString2ContentList<'t>>,
}

///
/// Type derived for non-terminal RawString2ContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2ContentList<'t> {
    pub raw_string2_content_list_group: RawString2ContentListGroup<'t>,
}

///
/// Type derived for non-terminal RawString2ContentListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RawString2ContentListGroup<'t> {
    RawStringContentNoQuotes(RawString2ContentListGroupRawStringContentNoQuotes<'t>),
    RawString2ContentQuotes(RawString2ContentListGroupRawString2ContentQuotes<'t>),
}

///
/// Type derived for non-terminal RawString2ContentQuotes
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2ContentQuotes<'t> {
    pub raw_string_end: Token<'t>, /* " */
}

///
/// Type derived for non-terminal RawString2End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2End<'t> {
    pub raw_string2_end: Token<'t>, /* "## */
}

///
/// Type derived for non-terminal RawString2Start
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString2Start<'t> {
    pub raw_string2_start: Token<'t>, /* r##" */
}

///
/// Type derived for non-terminal RawString3
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3<'t> {
    pub strng: RawString3Content<'t>,
}

///
/// Type derived for non-terminal RawString3Content
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3Content<'t> {
    pub raw_string3_content_list: Vec<RawString3ContentList<'t>>,
}

///
/// Type derived for non-terminal RawString3ContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3ContentList<'t> {
    pub raw_string3_content_list_group: RawString3ContentListGroup<'t>,
}

///
/// Type derived for non-terminal RawString3ContentListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RawString3ContentListGroup<'t> {
    RawStringContentNoQuotes(RawString3ContentListGroupRawStringContentNoQuotes<'t>),
    RawString3ContentQuotes(RawString3ContentListGroupRawString3ContentQuotes<'t>),
}

///
/// Type derived for non-terminal RawString3ContentQuotes
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3ContentQuotes<'t> {
    pub raw_string_end: Token<'t>, /* " */
}

///
/// Type derived for non-terminal RawString3End
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3End<'t> {
    pub raw_string3_end: Token<'t>, /* "\u{0023}{3} */
}

///
/// Type derived for non-terminal RawString3Start
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawString3Start<'t> {
    pub raw_string3_start: Token<'t>, /* r\u{0023}{3}" */
}

///
/// Type derived for non-terminal RawStringContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawStringContent<'t> {
    pub raw_string_content: Token<'t>, /* ([^"]|\\")* */
}

///
/// Type derived for non-terminal RawStringContentNoQuotes
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawStringContentNoQuotes<'t> {
    pub raw_string_content_no_quotes: Token<'t>, /* [^"]* */
}

///
/// Type derived for non-terminal RawStringEnd
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawStringEnd<'t> {
    pub raw_string_end: Token<'t>, /* " */
}

///
/// Type derived for non-terminal RawStringStart
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RawStringStart<'t> {
    pub raw_string_start: Token<'t>, /* r" */
}

///
/// Type derived for non-terminal Ref
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Ref<'t> {
    pub r#ref: Token<'t>, /* & */
}

///
/// Type derived for non-terminal ScannerMacro
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacro<'t> {
    pub scanner_bang: Token<'t>, /* scanner! */
}

///
/// Type derived for non-terminal ScannerMacroBody
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroBody {
    pub scanner_macro_body_list: Vec<ScannerMacroBodyList>,
}

///
/// Type derived for non-terminal ScannerMacroBodyList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroBodyList {}

///
/// Type derived for non-terminal ScannerMacroItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroItem {
    pub scanner_macro_item_list: Vec<ScannerMacroItemList>,
}

///
/// Type derived for non-terminal ScannerMacroItemList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScannerMacroItemList {
    pub scanner_macro_item_list_group: ScannerMacroItemListGroup,
}

///
/// Type derived for non-terminal ScannerMacroItemListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScannerMacroItemListGroup {
    TokenDefinition(ScannerMacroItemListGroupTokenDefinition),
    ModeTransition(ScannerMacroItemListGroupModeTransition),
}

///
/// Type derived for non-terminal ScopedList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedList<'t> {
    pub l_brace: LBrace<'t>,
    pub scoped_list_items: Box<ScopedListItems<'t>>,
    pub comma_opt: CommaOpt<'t>,
    pub r_brace: RBrace<'t>,
}

///
/// Type derived for non-terminal ScopedListItems
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedListItems<'t> {
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
    pub scoped_list_items_list: Vec<ScopedListItemsList<'t>>,
}

///
/// Type derived for non-terminal ScopedListItemsList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedListItemsList<'t> {
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
}

///
/// Type derived for non-terminal ScopedQualifiedIdent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedQualifiedIdent<'t> {
    pub qualified_ident: QualifiedIdent<'t>,
    pub scoped_qualified_ident_opt: Option<ScopedQualifiedIdentOpt<'t>>,
}

///
/// Type derived for non-terminal ScopedQualifiedIdentOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedQualifiedIdentOpt<'t> {
    pub double_colon: DoubleColon<'t>,
    pub scoped_list: ScopedList<'t>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Semicolon<'t> {
    pub semicolon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal Skip
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Skip<'t> {
    pub skip: Token<'t>, /* &\[Production; \d+\] = &\[(?s).* */
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum String<'t> {
    QuotedString(StringQuotedString<'t>),
    RawString(StringRawString<'t>),
    RawString1(StringRawString1<'t>),
    RawString2(StringRawString2<'t>),
    RawString3(StringRawString3<'t>),
}

///
/// Type derived for non-terminal StructOrTupleVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StructOrTupleVal<'t> {
    StructVal(StructOrTupleValStructVal<'t>),
    TupleStructVal(StructOrTupleValTupleStructVal<'t>),
}

///
/// Type derived for non-terminal StructVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructVal<'t> {
    pub struct_val_opt: Option<StructValOpt<'t>>,
}

///
/// Type derived for non-terminal StructValOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructValOpt<'t> {
    pub member_values: MemberValues<'t>,
}

///
/// Type derived for non-terminal TokenDefinition
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TokenDefinition {
    pub token_definition_opt: Option<TokenDefinitionOpt>,
}

///
/// Type derived for non-terminal TokenDefinitionOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TokenDefinitionOpt {}

///
/// Type derived for non-terminal Tuple
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Tuple<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_items: TupleItems<'t>,
    pub comma_opt: CommaOpt<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal TupleItems
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleItems<'t> {
    pub tuple_items_opt: Option<TupleItemsOpt<'t>>,
    pub type_spec: TypeSpec<'t>,
    pub tuple_items_list: Vec<TupleItemsList<'t>>,
}

///
/// Type derived for non-terminal TupleItemsList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleItemsList<'t> {
    pub comma: Comma<'t>,
    pub tuple_items_opt0: Option<TupleItemsOpt0<'t>>,
    pub type_spec: TypeSpec<'t>,
}

///
/// Type derived for non-terminal TupleItemsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleItemsOpt<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal TupleItemsOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleItemsOpt0<'t> {
    pub r#ref: Ref<'t>,
}

///
/// Type derived for non-terminal TupleStructVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleStructVal<'t> {
    pub tuple_val: TupleVal<'t>,
}

///
/// Type derived for non-terminal TupleType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleType<'t> {
    pub l_paren: LParen<'t>,
    pub tuple_items: TupleItems<'t>,
    pub comma_opt: CommaOpt<'t>,
    pub r_paren: RParen<'t>,
}

///
/// Type derived for non-terminal TupleVal
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleVal<'t> {
    pub tuple_val_opt: Option<TupleValOpt<'t>>,
}

///
/// Type derived for non-terminal TupleValOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TupleValOpt<'t> {
    pub const_val_list: ConstValList<'t>,
}

///
/// Type derived for non-terminal TypeSpec
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeSpec<'t> {
    QualifiedIdent(TypeSpecQualifiedIdent<'t>),
    ArrayType(TypeSpecArrayType<'t>),
    TupleType(TypeSpecTupleType<'t>),
    OptionType(TypeSpecOptionType<'t>),
}

///
/// Type derived for non-terminal UseStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UseStatement<'t> {
    pub r#use: Token<'t>, /* use */
    pub scoped_qualified_ident: ScopedQualifiedIdent<'t>,
    pub semicolon: Semicolon<'t>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    ArrayElementType(ArrayElementType<'t>),
    ArrayType(ArrayType<'t>),
    ArrayTypeSpec(ArrayTypeSpec<'t>),
    ArrayTypeSpecOpt(Option<ArrayTypeSpecOpt<'t>>),
    ArrayVal(ArrayVal<'t>),
    ArrayValOpt(Option<ArrayValOpt<'t>>),
    Arrow(Arrow<'t>),
    Assign(Assign<'t>),
    AttributeArgOpt(AttributeArgOpt<'t>),
    AttributeArgOpt0(Option<AttributeArgOpt0<'t>>),
    AttributeOpt(AttributeOpt<'t>),
    AttributeOpt0(Option<AttributeOpt0<'t>>),
    Colon(Colon<'t>),
    Comma(Comma<'t>),
    CommaOpt(CommaOpt<'t>),
    CommaOpt0(Option<CommaOpt0<'t>>),
    ConstDeclaration(ConstDeclaration<'t>),
    ConstName(ConstName<'t>),
    ConstPreamble(ConstPreamble<'t>),
    ConstQualifier(ConstQualifier<'t>),
    ConstQualifierOpt(Option<ConstQualifierOpt<'t>>),
    ConstVal(ConstVal<'t>),
    ConstValList(ConstValList<'t>),
    ConstValListList(Vec<ConstValListList<'t>>),
    DoubleColon(DoubleColon<'t>),
    GT(GT<'t>),
    Hash(Hash<'t>),
    Ident(Ident<'t>),
    Item(Item<'t>),
    LBrace(LBrace<'t>),
    LBracket(LBracket<'t>),
    LParen(LParen<'t>),
    LT(LT<'t>),
    LaDfa2Dot(LaDfa2Dot<'t>),
    LaDfa2DotList(Vec<LaDfa2DotList<'t>>),
    LookaheadExpression(LookaheadExpression<'t>),
    LookaheadExpressionOpt(Option<LookaheadExpressionOpt<'t>>),
    MemberValue(MemberValue<'t>),
    MemberValues(MemberValues<'t>),
    MemberValuesList(Vec<MemberValuesList<'t>>),
    ModeTransition(ModeTransition),
    Number(Number<'t>),
    OptionType(OptionType<'t>),
    QualifiedIdent(QualifiedIdent<'t>),
    QualifiedIdentList(Vec<QualifiedIdentList<'t>>),
    QualifiedVal(QualifiedVal<'t>),
    QualifiedValOpt(Option<QualifiedValOpt<'t>>),
    QuotedString(QuotedString<'t>),
    RBrace(RBrace<'t>),
    RBracket(RBracket<'t>),
    RParen(RParen<'t>),
    RawString(RawString<'t>),
    RawString1(RawString1<'t>),
    RawString1Content(RawString1Content<'t>),
    RawString1ContentList(Vec<RawString1ContentList<'t>>),
    RawString1ContentListGroup(RawString1ContentListGroup<'t>),
    RawString1ContentQuotes(RawString1ContentQuotes<'t>),
    RawString1End(RawString1End<'t>),
    RawString1Start(RawString1Start<'t>),
    RawString2(RawString2<'t>),
    RawString2Content(RawString2Content<'t>),
    RawString2ContentList(Vec<RawString2ContentList<'t>>),
    RawString2ContentListGroup(RawString2ContentListGroup<'t>),
    RawString2ContentQuotes(RawString2ContentQuotes<'t>),
    RawString2End(RawString2End<'t>),
    RawString2Start(RawString2Start<'t>),
    RawString3(RawString3<'t>),
    RawString3Content(RawString3Content<'t>),
    RawString3ContentList(Vec<RawString3ContentList<'t>>),
    RawString3ContentListGroup(RawString3ContentListGroup<'t>),
    RawString3ContentQuotes(RawString3ContentQuotes<'t>),
    RawString3End(RawString3End<'t>),
    RawString3Start(RawString3Start<'t>),
    RawStringContent(RawStringContent<'t>),
    RawStringContentNoQuotes(RawStringContentNoQuotes<'t>),
    RawStringEnd(RawStringEnd<'t>),
    RawStringStart(RawStringStart<'t>),
    Ref(Ref<'t>),
    ScannerMacro(ScannerMacro<'t>),
    ScannerMacroBody(ScannerMacroBody),
    ScannerMacroBodyList(Vec<ScannerMacroBodyList>),
    ScannerMacroItem(ScannerMacroItem),
    ScannerMacroItemList(Vec<ScannerMacroItemList>),
    ScannerMacroItemListGroup(ScannerMacroItemListGroup),
    ScopedList(ScopedList<'t>),
    ScopedListItems(ScopedListItems<'t>),
    ScopedListItemsList(Vec<ScopedListItemsList<'t>>),
    ScopedQualifiedIdent(ScopedQualifiedIdent<'t>),
    ScopedQualifiedIdentOpt(Option<ScopedQualifiedIdentOpt<'t>>),
    Semicolon(Semicolon<'t>),
    Skip(Skip<'t>),
    String(String<'t>),
    StructOrTupleVal(StructOrTupleVal<'t>),
    StructVal(StructVal<'t>),
    StructValOpt(Option<StructValOpt<'t>>),
    TokenDefinition(TokenDefinition),
    TokenDefinitionOpt(Option<TokenDefinitionOpt>),
    Tuple(Tuple<'t>),
    TupleItems(TupleItems<'t>),
    TupleItemsList(Vec<TupleItemsList<'t>>),
    TupleItemsOpt(Option<TupleItemsOpt<'t>>),
    TupleItemsOpt0(Option<TupleItemsOpt0<'t>>),
    TupleStructVal(TupleStructVal<'t>),
    TupleType(TupleType<'t>),
    TupleVal(TupleVal<'t>),
    TupleValOpt(Option<TupleValOpt<'t>>),
    TypeSpec(TypeSpec<'t>),
    UseStatement(UseStatement<'t>),
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct LaDfa2DotGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `LaDfa2DotGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> LaDfa2DotGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {context}: {item:?}");
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {context}: {item:?}");
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {s:?}"))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `LaDfa2Dot: LaDfa2DotList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot(&mut self, _la_dfa2_dot_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let la_dfa2_dot_list =
            pop_and_reverse_item!(self, la_dfa2_dot_list, LaDfa2DotList, context);
        let la_dfa2_dot_built = LaDfa2Dot { la_dfa2_dot_list };
        // Calling user action here
        self.user_grammar.la_dfa2_dot(&la_dfa2_dot_built)?;
        self.push(ASTType::LaDfa2Dot(la_dfa2_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `LaDfa2DotList /* Vec<T>::Push */: AttributeOpt^ /* Clipped */ Item LaDfa2DotList;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot_list_0(
        &mut self,
        _attribute_opt: &ParseTreeType<'t>,
        _item: &ParseTreeType<'t>,
        _la_dfa2_dot_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut la_dfa2_dot_list = pop_item!(self, la_dfa2_dot_list, LaDfa2DotList, context);
        let item = pop_item!(self, item, Item, context);
        self.pop(context);
        let la_dfa2_dot_list_0_built = LaDfa2DotList { item };
        // Add an element to the vector
        la_dfa2_dot_list.push(la_dfa2_dot_list_0_built);
        self.push(ASTType::LaDfa2DotList(la_dfa2_dot_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `LaDfa2DotList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let la_dfa2_dot_list_1_built = Vec::new();
        self.push(ASTType::LaDfa2DotList(la_dfa2_dot_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `AttributeOpt: AttributeOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt(&mut self, _attribute_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_opt0 = pop_item!(self, attribute_opt0, AttributeOpt0, context);
        let attribute_opt_built = AttributeOpt { attribute_opt0 };
        // Calling user action here
        self.user_grammar.attribute_opt(&attribute_opt_built)?;
        self.push(ASTType::AttributeOpt(attribute_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `AttributeOpt0 /* Option<T>::Some */: Hash LBracket Ident AttributeArgOpt RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt0_0(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _attribute_arg_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let attribute_arg_opt = pop_item!(self, attribute_arg_opt, AttributeArgOpt, context);
        let ident = pop_item!(self, ident, Ident, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let hash = pop_item!(self, hash, Hash, context);
        let attribute_opt0_0_built = AttributeOpt0 {
            hash,
            l_bracket,
            ident,
            attribute_arg_opt,
            r_bracket,
        };
        self.push(
            ASTType::AttributeOpt0(Some(attribute_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `AttributeOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `AttributeArgOpt: AttributeArgOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt(&mut self, _attribute_arg_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_arg_opt0 = pop_item!(self, attribute_arg_opt0, AttributeArgOpt0, context);
        let attribute_arg_opt_built = AttributeArgOpt { attribute_arg_opt0 };
        // Calling user action here
        self.user_grammar
            .attribute_arg_opt(&attribute_arg_opt_built)?;
        self.push(ASTType::AttributeArgOpt(attribute_arg_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `AttributeArgOpt0 /* Option<T>::Some */: LParen Ident RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt0_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let ident = pop_item!(self, ident, Ident, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let attribute_arg_opt0_0_built = AttributeArgOpt0 {
            l_paren,
            ident,
            r_paren,
        };
        self.push(
            ASTType::AttributeArgOpt0(Some(attribute_arg_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `AttributeArgOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_arg_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeArgOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `Item: UseStatement^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn item_0(&mut self, _use_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let item_0_built = ItemUseStatement {};
        let item_0_built = Item::UseStatement(item_0_built);
        // Calling user action here
        self.user_grammar.item(&item_0_built)?;
        self.push(ASTType::Item(item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `Item: ConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn item_1(&mut self, _const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_declaration = pop_item!(self, const_declaration, ConstDeclaration, context);
        let item_1_built = ItemConstDeclaration { const_declaration };
        let item_1_built = Item::ConstDeclaration(item_1_built);
        // Calling user action here
        self.user_grammar.item(&item_1_built)?;
        self.push(ASTType::Item(item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `Item: ScannerMacro;`
    ///
    #[parol_runtime::function_name::named]
    fn item_2(&mut self, _scanner_macro: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_macro = pop_item!(self, scanner_macro, ScannerMacro, context);
        let item_2_built = ItemScannerMacro { scanner_macro };
        let item_2_built = Item::ScannerMacro(item_2_built);
        // Calling user action here
        self.user_grammar.item(&item_2_built)?;
        self.push(ASTType::Item(item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `UseStatement: 'use' ScopedQualifiedIdent Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn use_statement(
        &mut self,
        r#use: &ParseTreeType<'t>,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#use = r#use.token()?.clone();
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        let use_statement_built = UseStatement {
            r#use,
            scoped_qualified_ident,
            semicolon,
        };
        // Calling user action here
        self.user_grammar.use_statement(&use_statement_built)?;
        self.push(ASTType::UseStatement(use_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `QualifiedIdent: Ident QualifiedIdentList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _qualified_ident_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident_list =
            pop_and_reverse_item!(self, qualified_ident_list, QualifiedIdentList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let qualified_ident_built = QualifiedIdent {
            ident,
            qualified_ident_list,
        };
        // Calling user action here
        self.user_grammar.qualified_ident(&qualified_ident_built)?;
        self.push(ASTType::QualifiedIdent(qualified_ident_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `QualifiedIdentList /* Vec<T>::Push */: DoubleColon Ident QualifiedIdentList;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident_list_0(
        &mut self,
        _double_colon: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _qualified_ident_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut qualified_ident_list =
            pop_item!(self, qualified_ident_list, QualifiedIdentList, context);
        let ident = pop_item!(self, ident, Ident, context);
        let double_colon = pop_item!(self, double_colon, DoubleColon, context);
        let qualified_ident_list_0_built = QualifiedIdentList {
            ident,
            double_colon,
        };
        // Add an element to the vector
        qualified_ident_list.push(qualified_ident_list_0_built);
        self.push(ASTType::QualifiedIdentList(qualified_ident_list), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `QualifiedIdentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_ident_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident_list_1_built = Vec::new();
        self.push(
            ASTType::QualifiedIdentList(qualified_ident_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `ScopedQualifiedIdent: QualifiedIdent ScopedQualifiedIdentOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident(
        &mut self,
        _qualified_ident: &ParseTreeType<'t>,
        _scoped_qualified_ident_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_qualified_ident_opt = pop_item!(
            self,
            scoped_qualified_ident_opt,
            ScopedQualifiedIdentOpt,
            context
        );
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let scoped_qualified_ident_built = ScopedQualifiedIdent {
            qualified_ident,
            scoped_qualified_ident_opt,
        };
        // Calling user action here
        self.user_grammar
            .scoped_qualified_ident(&scoped_qualified_ident_built)?;
        self.push(
            ASTType::ScopedQualifiedIdent(scoped_qualified_ident_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `ScopedQualifiedIdentOpt /* Option<T>::Some */: DoubleColon ScopedList;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident_opt_0(
        &mut self,
        _double_colon: &ParseTreeType<'t>,
        _scoped_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list = pop_item!(self, scoped_list, ScopedList, context);
        let double_colon = pop_item!(self, double_colon, DoubleColon, context);
        let scoped_qualified_ident_opt_0_built = ScopedQualifiedIdentOpt {
            double_colon,
            scoped_list,
        };
        self.push(
            ASTType::ScopedQualifiedIdentOpt(Some(scoped_qualified_ident_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `ScopedQualifiedIdentOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_qualified_ident_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScopedQualifiedIdentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `ScopedList: LBrace ScopedListItems CommaOpt RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _scoped_list_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let scoped_list_items = pop_item!(self, scoped_list_items, ScopedListItems, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let scoped_list_built = ScopedList {
            l_brace,
            scoped_list_items: Box::new(scoped_list_items),
            comma_opt,
            r_brace,
        };
        // Calling user action here
        self.user_grammar.scoped_list(&scoped_list_built)?;
        self.push(ASTType::ScopedList(scoped_list_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `ScopedListItems: ScopedQualifiedIdent ScopedListItemsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items(
        &mut self,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _scoped_list_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list_items_list =
            pop_and_reverse_item!(self, scoped_list_items_list, ScopedListItemsList, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        let scoped_list_items_built = ScopedListItems {
            scoped_qualified_ident,
            scoped_list_items_list,
        };
        // Calling user action here
        self.user_grammar
            .scoped_list_items(&scoped_list_items_built)?;
        self.push(ASTType::ScopedListItems(scoped_list_items_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `ScopedListItemsList /* Vec<T>::Push */: Comma^ /* Clipped */ ScopedQualifiedIdent ScopedListItemsList;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _scoped_qualified_ident: &ParseTreeType<'t>,
        _scoped_list_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_list_items_list =
            pop_item!(self, scoped_list_items_list, ScopedListItemsList, context);
        let scoped_qualified_ident =
            pop_item!(self, scoped_qualified_ident, ScopedQualifiedIdent, context);
        self.pop(context);
        let scoped_list_items_list_0_built = ScopedListItemsList {
            scoped_qualified_ident,
        };
        // Add an element to the vector
        scoped_list_items_list.push(scoped_list_items_list_0_built);
        self.push(
            ASTType::ScopedListItemsList(scoped_list_items_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `ScopedListItemsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_list_items_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_list_items_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedListItemsList(scoped_list_items_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `ConstDeclaration: ConstPreamble TypeSpec^ /* Clipped */ Assign^ /* Clipped */ ConstVal Semicolon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_0(
        &mut self,
        _const_preamble: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _assign: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        self.pop(context);
        let const_preamble = pop_item!(self, const_preamble, ConstPreamble, context);
        let const_declaration_0_built =
            ConstDeclarationConstPreambleTypeSpecAssignConstValSemicolon {
                const_preamble,
                const_val,
            };
        let const_declaration_0_built =
            ConstDeclaration::ConstPreambleTypeSpecAssignConstValSemicolon(
                const_declaration_0_built,
            );
        // Calling user action here
        self.user_grammar
            .const_declaration(&const_declaration_0_built)?;
        self.push(
            ASTType::ConstDeclaration(const_declaration_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `ConstDeclaration: ConstPreamble^ /* Clipped */ Skip^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_1(
        &mut self,
        _const_preamble: &ParseTreeType<'t>,
        _skip: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        let const_declaration_1_built = ConstDeclarationConstPreambleSkip {};
        let const_declaration_1_built =
            ConstDeclaration::ConstPreambleSkip(const_declaration_1_built);
        // Calling user action here
        self.user_grammar
            .const_declaration(&const_declaration_1_built)?;
        self.push(
            ASTType::ConstDeclaration(const_declaration_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ConstPreamble: ConstQualifier^ /* Clipped */ ConstName Colon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_preamble(
        &mut self,
        _const_qualifier: &ParseTreeType<'t>,
        _const_name: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_name = pop_item!(self, const_name, ConstName, context);
        self.pop(context);
        let const_preamble_built = ConstPreamble { const_name };
        // Calling user action here
        self.user_grammar.const_preamble(&const_preamble_built)?;
        self.push(ASTType::ConstPreamble(const_preamble_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `ConstQualifier: ConstQualifierOpt /* Option */ 'const';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_0(
        &mut self,
        _const_qualifier_opt: &ParseTreeType<'t>,
        r#const: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#const = r#const.token()?.clone();
        let const_qualifier_opt = pop_item!(self, const_qualifier_opt, ConstQualifierOpt, context);
        let const_qualifier_0_built = ConstQualifierConstQualifierOptConst {
            const_qualifier_opt,
            r#const,
        };
        let const_qualifier_0_built =
            ConstQualifier::ConstQualifierOptConst(const_qualifier_0_built);
        // Calling user action here
        self.user_grammar
            .const_qualifier(&const_qualifier_0_built)?;
        self.push(ASTType::ConstQualifier(const_qualifier_0_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ConstQualifier: 'static';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_1(&mut self, r#static: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#static = r#static.token()?.clone();
        let const_qualifier_1_built = ConstQualifierStatic { r#static };
        let const_qualifier_1_built = ConstQualifier::Static(const_qualifier_1_built);
        // Calling user action here
        self.user_grammar
            .const_qualifier(&const_qualifier_1_built)?;
        self.push(ASTType::ConstQualifier(const_qualifier_1_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `ConstQualifierOpt /* Option<T>::Some */: 'pub';`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_opt_0(&mut self, r#pub: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#pub = r#pub.token()?.clone();
        let const_qualifier_opt_0_built = ConstQualifierOpt { r#pub };
        self.push(
            ASTType::ConstQualifierOpt(Some(const_qualifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `ConstQualifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn const_qualifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConstQualifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `ConstName: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn const_name(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let const_name_built = ConstName { ident };
        // Calling user action here
        self.user_grammar.const_name(&const_name_built)?;
        self.push(ASTType::ConstName(const_name_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `ConstVal: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_0(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let const_val_0_built = ConstValNumber { number };
        let const_val_0_built = ConstVal::Number(const_val_0_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_0_built)?;
        self.push(ASTType::ConstVal(const_val_0_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `ConstVal: String;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_1(&mut self, _string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let const_val_1_built = ConstValString { string };
        let const_val_1_built = ConstVal::String(const_val_1_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_1_built)?;
        self.push(ASTType::ConstVal(const_val_1_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `ConstVal: QualifiedVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_2(&mut self, _qualified_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_val = pop_item!(self, qualified_val, QualifiedVal, context);
        let const_val_2_built = ConstValQualifiedVal {
            qualified_val: Box::new(qualified_val),
        };
        let const_val_2_built = ConstVal::QualifiedVal(const_val_2_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_2_built)?;
        self.push(ASTType::ConstVal(const_val_2_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `ConstVal: ArrayVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_3(&mut self, _array_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_val = pop_item!(self, array_val, ArrayVal, context);
        let const_val_3_built = ConstValArrayVal {
            array_val: Box::new(array_val),
        };
        let const_val_3_built = ConstVal::ArrayVal(const_val_3_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_3_built)?;
        self.push(ASTType::ConstVal(const_val_3_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `ConstVal: TupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_4(&mut self, _tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_val = pop_item!(self, tuple_val, TupleVal, context);
        let const_val_4_built = ConstValTupleVal {
            tuple_val: Box::new(tuple_val),
        };
        let const_val_4_built = ConstVal::TupleVal(const_val_4_built);
        // Calling user action here
        self.user_grammar.const_val(&const_val_4_built)?;
        self.push(ASTType::ConstVal(const_val_4_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `ArrayVal: Ref^ /* Clipped */ LBracket^ /* Clipped */ ArrayValOpt /* Option */ RBracket^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val(
        &mut self,
        _ref: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _array_val_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let array_val_opt = pop_item!(self, array_val_opt, ArrayValOpt, context);
        self.pop(context);
        self.pop(context);
        let array_val_built = ArrayVal { array_val_opt };
        // Calling user action here
        self.user_grammar.array_val(&array_val_built)?;
        self.push(ASTType::ArrayVal(array_val_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `ArrayValOpt /* Option<T>::Some */: ConstValList CommaOpt^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val_opt_0(
        &mut self,
        _const_val_list: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val_list = pop_item!(self, const_val_list, ConstValList, context);
        let array_val_opt_0_built = ArrayValOpt { const_val_list };
        self.push(ASTType::ArrayValOpt(Some(array_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `ArrayValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `ConstValList: ConstVal ConstValListList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list(
        &mut self,
        _const_val: &ParseTreeType<'t>,
        _const_val_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val_list_list =
            pop_and_reverse_item!(self, const_val_list_list, ConstValListList, context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        let const_val_list_built = ConstValList {
            const_val,
            const_val_list_list,
        };
        // Calling user action here
        self.user_grammar.const_val_list(&const_val_list_built)?;
        self.push(ASTType::ConstValList(const_val_list_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `ConstValListList /* Vec<T>::Push */: Comma^ /* Clipped */ ConstVal ConstValListList;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
        _const_val_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut const_val_list_list =
            pop_item!(self, const_val_list_list, ConstValListList, context);
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        let const_val_list_list_0_built = ConstValListList { const_val };
        // Add an element to the vector
        const_val_list_list.push(const_val_list_list_0_built);
        self.push(ASTType::ConstValListList(const_val_list_list), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `ConstValListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn const_val_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val_list_list_1_built = Vec::new();
        self.push(
            ASTType::ConstValListList(const_val_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `TupleVal: LParen^ /* Clipped */ TupleValOpt /* Option */ RParen^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_val_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let tuple_val_opt = pop_item!(self, tuple_val_opt, TupleValOpt, context);
        self.pop(context);
        let tuple_val_built = TupleVal { tuple_val_opt };
        // Calling user action here
        self.user_grammar.tuple_val(&tuple_val_built)?;
        self.push(ASTType::TupleVal(tuple_val_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `TupleValOpt /* Option<T>::Some */: ConstValList CommaOpt^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val_opt_0(
        &mut self,
        _const_val_list: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let const_val_list = pop_item!(self, const_val_list, ConstValList, context);
        let tuple_val_opt_0_built = TupleValOpt { const_val_list };
        self.push(ASTType::TupleValOpt(Some(tuple_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `TupleValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `QualifiedVal: QualifiedIdent QualifiedValOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val(
        &mut self,
        _qualified_ident: &ParseTreeType<'t>,
        _qualified_val_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_val_opt = pop_item!(self, qualified_val_opt, QualifiedValOpt, context);
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let qualified_val_built = QualifiedVal {
            qualified_ident,
            qualified_val_opt,
        };
        // Calling user action here
        self.user_grammar.qualified_val(&qualified_val_built)?;
        self.push(ASTType::QualifiedVal(qualified_val_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `QualifiedValOpt /* Option<T>::Some */: StructOrTupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val_opt_0(&mut self, _struct_or_tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_or_tuple_val = pop_item!(self, struct_or_tuple_val, StructOrTupleVal, context);
        let qualified_val_opt_0_built = QualifiedValOpt {
            struct_or_tuple_val,
        };
        self.push(
            ASTType::QualifiedValOpt(Some(qualified_val_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `QualifiedValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn qualified_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::QualifiedValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `StructOrTupleVal: StructVal;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_or_tuple_val_0(&mut self, _struct_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_val = pop_item!(self, struct_val, StructVal, context);
        let struct_or_tuple_val_0_built = StructOrTupleValStructVal { struct_val };
        let struct_or_tuple_val_0_built = StructOrTupleVal::StructVal(struct_or_tuple_val_0_built);
        // Calling user action here
        self.user_grammar
            .struct_or_tuple_val(&struct_or_tuple_val_0_built)?;
        self.push(
            ASTType::StructOrTupleVal(struct_or_tuple_val_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `StructOrTupleVal: TupleStructVal;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_or_tuple_val_1(&mut self, _tuple_struct_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_struct_val = pop_item!(self, tuple_struct_val, TupleStructVal, context);
        let struct_or_tuple_val_1_built = StructOrTupleValTupleStructVal { tuple_struct_val };
        let struct_or_tuple_val_1_built =
            StructOrTupleVal::TupleStructVal(struct_or_tuple_val_1_built);
        // Calling user action here
        self.user_grammar
            .struct_or_tuple_val(&struct_or_tuple_val_1_built)?;
        self.push(
            ASTType::StructOrTupleVal(struct_or_tuple_val_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `StructVal: LBrace^ /* Clipped */ StructValOpt /* Option */ RBrace^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _struct_val_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let struct_val_opt = pop_item!(self, struct_val_opt, StructValOpt, context);
        self.pop(context);
        let struct_val_built = StructVal { struct_val_opt };
        // Calling user action here
        self.user_grammar.struct_val(&struct_val_built)?;
        self.push(ASTType::StructVal(struct_val_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `StructValOpt /* Option<T>::Some */: MemberValues Comma^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val_opt_0(
        &mut self,
        _member_values: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let member_values = pop_item!(self, member_values, MemberValues, context);
        let struct_val_opt_0_built = StructValOpt { member_values };
        self.push(ASTType::StructValOpt(Some(struct_val_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `StructValOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_val_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructValOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `MemberValues: MemberValue MemberValuesList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values(
        &mut self,
        _member_value: &ParseTreeType<'t>,
        _member_values_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let member_values_list =
            pop_and_reverse_item!(self, member_values_list, MemberValuesList, context);
        let member_value = pop_item!(self, member_value, MemberValue, context);
        let member_values_built = MemberValues {
            member_value,
            member_values_list,
        };
        // Calling user action here
        self.user_grammar.member_values(&member_values_built)?;
        self.push(ASTType::MemberValues(member_values_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `MemberValuesList /* Vec<T>::Push */: Comma^ /* Clipped */ MemberValue MemberValuesList;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _member_value: &ParseTreeType<'t>,
        _member_values_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut member_values_list = pop_item!(self, member_values_list, MemberValuesList, context);
        let member_value = pop_item!(self, member_value, MemberValue, context);
        self.pop(context);
        let member_values_list_0_built = MemberValuesList { member_value };
        // Add an element to the vector
        member_values_list.push(member_values_list_0_built);
        self.push(ASTType::MemberValuesList(member_values_list), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `MemberValuesList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn member_values_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let member_values_list_1_built = Vec::new();
        self.push(
            ASTType::MemberValuesList(member_values_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `MemberValue: Ident Colon^ /* Clipped */ ConstVal;`
    ///
    #[parol_runtime::function_name::named]
    fn member_value(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _const_val: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_val = pop_item!(self, const_val, ConstVal, context);
        self.pop(context);
        let ident = pop_item!(self, ident, Ident, context);
        let member_value_built = MemberValue { ident, const_val };
        // Calling user action here
        self.user_grammar.member_value(&member_value_built)?;
        self.push(ASTType::MemberValue(member_value_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `TupleStructVal: TupleVal;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_struct_val(&mut self, _tuple_val: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_val = pop_item!(self, tuple_val, TupleVal, context);
        let tuple_struct_val_built = TupleStructVal { tuple_val };
        // Calling user action here
        self.user_grammar
            .tuple_struct_val(&tuple_struct_val_built)?;
        self.push(ASTType::TupleStructVal(tuple_struct_val_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `ScannerMacro: 'scanner!' LBrace^ /* Clipped */ ScannerMacroBody^ /* Clipped */ RBrace^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro(
        &mut self,
        scanner_bang: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _scanner_macro_body: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_bang = scanner_bang.token()?.clone();
        self.pop(context);
        self.pop(context);
        self.pop(context);
        let scanner_macro_built = ScannerMacro { scanner_bang };
        // Calling user action here
        self.user_grammar.scanner_macro(&scanner_macro_built)?;
        self.push(ASTType::ScannerMacro(scanner_macro_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `ScannerMacroBody: Ident^ /* Clipped */ LBrace^ /* Clipped */ ScannerMacroItem^ /* Clipped */ ScannerMacroBodyList /* Vec */ RBrace^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_body(
        &mut self,
        _ident: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _scanner_macro_item: &ParseTreeType<'t>,
        _scanner_macro_body_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let scanner_macro_body_list =
            pop_and_reverse_item!(self, scanner_macro_body_list, ScannerMacroBodyList, context);
        self.pop(context);
        self.pop(context);
        self.pop(context);
        let scanner_macro_body_built = ScannerMacroBody {
            scanner_macro_body_list,
        };
        // Calling user action here
        self.user_grammar
            .scanner_macro_body(&scanner_macro_body_built)?;
        self.push(ASTType::ScannerMacroBody(scanner_macro_body_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `ScannerMacroBodyList /* Vec<T>::Push */: ScannerMacroItem^ /* Clipped */ ScannerMacroBodyList;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_body_list_0(
        &mut self,
        _scanner_macro_item: &ParseTreeType<'t>,
        _scanner_macro_body_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scanner_macro_body_list =
            pop_item!(self, scanner_macro_body_list, ScannerMacroBodyList, context);
        self.pop(context);
        let scanner_macro_body_list_0_built = ScannerMacroBodyList {};
        // Add an element to the vector
        scanner_macro_body_list.push(scanner_macro_body_list_0_built);
        self.push(
            ASTType::ScannerMacroBodyList(scanner_macro_body_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `ScannerMacroBodyList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_body_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_macro_body_list_1_built = Vec::new();
        self.push(
            ASTType::ScannerMacroBodyList(scanner_macro_body_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `ScannerMacroItem: 'mode'^ /* Clipped */ Ident^ /* Clipped */ LBrace^ /* Clipped */ ScannerMacroItemList /* Vec */ RBrace^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_item(
        &mut self,
        _mode: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _scanner_macro_item_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let scanner_macro_item_list =
            pop_and_reverse_item!(self, scanner_macro_item_list, ScannerMacroItemList, context);
        self.pop(context);
        self.pop(context);
        let scanner_macro_item_built = ScannerMacroItem {
            scanner_macro_item_list,
        };
        // Calling user action here
        self.user_grammar
            .scanner_macro_item(&scanner_macro_item_built)?;
        self.push(ASTType::ScannerMacroItem(scanner_macro_item_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `ScannerMacroItemList /* Vec<T>::Push */: ScannerMacroItemListGroup ScannerMacroItemList;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_item_list_0(
        &mut self,
        _scanner_macro_item_list_group: &ParseTreeType<'t>,
        _scanner_macro_item_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scanner_macro_item_list =
            pop_item!(self, scanner_macro_item_list, ScannerMacroItemList, context);
        let scanner_macro_item_list_group = pop_item!(
            self,
            scanner_macro_item_list_group,
            ScannerMacroItemListGroup,
            context
        );
        let scanner_macro_item_list_0_built = ScannerMacroItemList {
            scanner_macro_item_list_group,
        };
        // Add an element to the vector
        scanner_macro_item_list.push(scanner_macro_item_list_0_built);
        self.push(
            ASTType::ScannerMacroItemList(scanner_macro_item_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `ScannerMacroItemListGroup: TokenDefinition^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_item_list_group_0(
        &mut self,
        _token_definition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let scanner_macro_item_list_group_0_built = ScannerMacroItemListGroupTokenDefinition {};
        let scanner_macro_item_list_group_0_built =
            ScannerMacroItemListGroup::TokenDefinition(scanner_macro_item_list_group_0_built);
        self.push(
            ASTType::ScannerMacroItemListGroup(scanner_macro_item_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `ScannerMacroItemListGroup: ModeTransition^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_item_list_group_1(
        &mut self,
        _mode_transition: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let scanner_macro_item_list_group_1_built = ScannerMacroItemListGroupModeTransition {};
        let scanner_macro_item_list_group_1_built =
            ScannerMacroItemListGroup::ModeTransition(scanner_macro_item_list_group_1_built);
        self.push(
            ASTType::ScannerMacroItemListGroup(scanner_macro_item_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `ScannerMacroItemList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scanner_macro_item_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scanner_macro_item_list_1_built = Vec::new();
        self.push(
            ASTType::ScannerMacroItemList(scanner_macro_item_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `TokenDefinition: 'token'^ /* Clipped */ String^ /* Clipped */ TokenDefinitionOpt /* Option */ Arrow^ /* Clipped */ Number^ /* Clipped */ Semicolon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_definition(
        &mut self,
        _token: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
        _token_definition_opt: &ParseTreeType<'t>,
        _arrow: &ParseTreeType<'t>,
        _number: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        self.pop(context);
        let token_definition_opt =
            pop_item!(self, token_definition_opt, TokenDefinitionOpt, context);
        self.pop(context);
        let token_definition_built = TokenDefinition {
            token_definition_opt,
        };
        // Calling user action here
        self.user_grammar
            .token_definition(&token_definition_built)?;
        self.push(ASTType::TokenDefinition(token_definition_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `TokenDefinitionOpt /* Option<T>::Some */: LookaheadExpression^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn token_definition_opt_0(&mut self, _lookahead_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let token_definition_opt_0_built = TokenDefinitionOpt {};
        self.push(
            ASTType::TokenDefinitionOpt(Some(token_definition_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `TokenDefinitionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn token_definition_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TokenDefinitionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `ModeTransition: 'on'^ /* Clipped */ Number^ /* Clipped */ 'enter'^ /* Clipped */ Ident^ /* Clipped */ Semicolon^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn mode_transition(
        &mut self,
        _on: &ParseTreeType<'t>,
        _number: &ParseTreeType<'t>,
        _enter: &ParseTreeType<'t>,
        _ident: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        self.pop(context);
        self.pop(context);
        let mode_transition_built = ModeTransition {};
        // Calling user action here
        self.user_grammar.mode_transition(&mode_transition_built)?;
        self.push(ASTType::ModeTransition(mode_transition_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `LookaheadExpression: LookaheadExpressionOpt /* Option */ 'followed'^ /* Clipped */ 'by'^ /* Clipped */ String^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn lookahead_expression(
        &mut self,
        _lookahead_expression_opt: &ParseTreeType<'t>,
        _followed: &ParseTreeType<'t>,
        _by: &ParseTreeType<'t>,
        _string: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let lookahead_expression_opt = pop_item!(
            self,
            lookahead_expression_opt,
            LookaheadExpressionOpt,
            context
        );
        let lookahead_expression_built = LookaheadExpression {
            lookahead_expression_opt,
        };
        // Calling user action here
        self.user_grammar
            .lookahead_expression(&lookahead_expression_built)?;
        self.push(
            ASTType::LookaheadExpression(lookahead_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `LookaheadExpressionOpt /* Option<T>::Some */: 'not';`
    ///
    #[parol_runtime::function_name::named]
    fn lookahead_expression_opt_0(&mut self, not: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let not = not.token()?.clone();
        let lookahead_expression_opt_0_built = LookaheadExpressionOpt { not };
        self.push(
            ASTType::LookaheadExpressionOpt(Some(lookahead_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `LookaheadExpressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn lookahead_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LookaheadExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `TypeSpec: QualifiedIdent;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_0(&mut self, _qualified_ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let qualified_ident = pop_item!(self, qualified_ident, QualifiedIdent, context);
        let type_spec_0_built = TypeSpecQualifiedIdent { qualified_ident };
        let type_spec_0_built = TypeSpec::QualifiedIdent(type_spec_0_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_0_built)?;
        self.push(ASTType::TypeSpec(type_spec_0_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `TypeSpec: ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_1(&mut self, _array_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let type_spec_1_built = TypeSpecArrayType {
            array_type: Box::new(array_type),
        };
        let type_spec_1_built = TypeSpec::ArrayType(type_spec_1_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_1_built)?;
        self.push(ASTType::TypeSpec(type_spec_1_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `TypeSpec: TupleType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_2(&mut self, _tuple_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_type = pop_item!(self, tuple_type, TupleType, context);
        let type_spec_2_built = TypeSpecTupleType {
            tuple_type: Box::new(tuple_type),
        };
        let type_spec_2_built = TypeSpec::TupleType(type_spec_2_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_2_built)?;
        self.push(ASTType::TypeSpec(type_spec_2_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `TypeSpec: OptionType;`
    ///
    #[parol_runtime::function_name::named]
    fn type_spec_3(&mut self, _option_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let option_type = pop_item!(self, option_type, OptionType, context);
        let type_spec_3_built = TypeSpecOptionType {
            option_type: Box::new(option_type),
        };
        let type_spec_3_built = TypeSpec::OptionType(type_spec_3_built);
        // Calling user action here
        self.user_grammar.type_spec(&type_spec_3_built)?;
        self.push(ASTType::TypeSpec(type_spec_3_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `ArrayType: Ref LBracket ArrayTypeSpec RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type(
        &mut self,
        _ref: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _array_type_spec: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let array_type_spec = pop_item!(self, array_type_spec, ArrayTypeSpec, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let array_type_built = ArrayType {
            r#ref,
            l_bracket,
            array_type_spec,
            r_bracket,
        };
        // Calling user action here
        self.user_grammar.array_type(&array_type_built)?;
        self.push(ASTType::ArrayType(array_type_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `ArrayTypeSpec: ArrayTypeSpecOpt /* Option */ ArrayElementType Semicolon Number;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec(
        &mut self,
        _array_type_spec_opt: &ParseTreeType<'t>,
        _array_element_type: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
        _number: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let array_element_type = pop_item!(self, array_element_type, ArrayElementType, context);
        let array_type_spec_opt = pop_item!(self, array_type_spec_opt, ArrayTypeSpecOpt, context);
        let array_type_spec_built = ArrayTypeSpec {
            array_type_spec_opt,
            array_element_type,
            semicolon,
            number,
        };
        // Calling user action here
        self.user_grammar.array_type_spec(&array_type_spec_built)?;
        self.push(ASTType::ArrayTypeSpec(array_type_spec_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `ArrayTypeSpecOpt /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec_opt_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let array_type_spec_opt_0_built = ArrayTypeSpecOpt { r#ref };
        self.push(
            ASTType::ArrayTypeSpecOpt(Some(array_type_spec_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `ArrayTypeSpecOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_spec_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayTypeSpecOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `ArrayElementType: Ident;`
    ///
    #[parol_runtime::function_name::named]
    fn array_element_type_0(&mut self, _ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = pop_item!(self, ident, Ident, context);
        let array_element_type_0_built = ArrayElementTypeIdent { ident };
        let array_element_type_0_built = ArrayElementType::Ident(array_element_type_0_built);
        // Calling user action here
        self.user_grammar
            .array_element_type(&array_element_type_0_built)?;
        self.push(
            ASTType::ArrayElementType(array_element_type_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `ArrayElementType: Tuple;`
    ///
    #[parol_runtime::function_name::named]
    fn array_element_type_1(&mut self, _tuple: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple = pop_item!(self, tuple, Tuple, context);
        let array_element_type_1_built = ArrayElementTypeTuple { tuple };
        let array_element_type_1_built = ArrayElementType::Tuple(array_element_type_1_built);
        // Calling user action here
        self.user_grammar
            .array_element_type(&array_element_type_1_built)?;
        self.push(
            ASTType::ArrayElementType(array_element_type_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `OptionType: 'Option' LT TypeSpec GT;`
    ///
    #[parol_runtime::function_name::named]
    fn option_type(
        &mut self,
        option: &ParseTreeType<'t>,
        _l_t: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _g_t: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let option = option.token()?.clone();
        let g_t = pop_item!(self, g_t, GT, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let l_t = pop_item!(self, l_t, LT, context);
        let option_type_built = OptionType {
            option,
            l_t,
            type_spec,
            g_t,
        };
        // Calling user action here
        self.user_grammar.option_type(&option_type_built)?;
        self.push(ASTType::OptionType(option_type_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `Tuple: LParen TupleItems CommaOpt RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let tuple_items = pop_item!(self, tuple_items, TupleItems, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_built = Tuple {
            l_paren,
            tuple_items,
            comma_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple(&tuple_built)?;
        self.push(ASTType::Tuple(tuple_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `TupleType: LParen TupleItems CommaOpt RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_type(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _tuple_items: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let comma_opt = pop_item!(self, comma_opt, CommaOpt, context);
        let tuple_items = pop_item!(self, tuple_items, TupleItems, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let tuple_type_built = TupleType {
            l_paren,
            tuple_items,
            comma_opt,
            r_paren,
        };
        // Calling user action here
        self.user_grammar.tuple_type(&tuple_type_built)?;
        self.push(ASTType::TupleType(tuple_type_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `TupleItems: TupleItemsOpt /* Option */ TypeSpec TupleItemsList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items(
        &mut self,
        _tuple_items_opt: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _tuple_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_items_list =
            pop_and_reverse_item!(self, tuple_items_list, TupleItemsList, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let tuple_items_opt = pop_item!(self, tuple_items_opt, TupleItemsOpt, context);
        let tuple_items_built = TupleItems {
            tuple_items_opt,
            type_spec,
            tuple_items_list,
        };
        // Calling user action here
        self.user_grammar.tuple_items(&tuple_items_built)?;
        self.push(ASTType::TupleItems(tuple_items_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `TupleItemsList /* Vec<T>::Push */: Comma TupleItemsOpt0 /* Option */ TypeSpec TupleItemsList;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _tuple_items_opt0: &ParseTreeType<'t>,
        _type_spec: &ParseTreeType<'t>,
        _tuple_items_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut tuple_items_list = pop_item!(self, tuple_items_list, TupleItemsList, context);
        let type_spec = pop_item!(self, type_spec, TypeSpec, context);
        let tuple_items_opt0 = pop_item!(self, tuple_items_opt0, TupleItemsOpt0, context);
        let comma = pop_item!(self, comma, Comma, context);
        let tuple_items_list_0_built = TupleItemsList {
            type_spec,
            tuple_items_opt0,
            comma,
        };
        // Add an element to the vector
        tuple_items_list.push(tuple_items_list_0_built);
        self.push(ASTType::TupleItemsList(tuple_items_list), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `TupleItemsList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tuple_items_list_1_built = Vec::new();
        self.push(ASTType::TupleItemsList(tuple_items_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `TupleItemsOpt0 /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt0_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let tuple_items_opt0_0_built = TupleItemsOpt0 { r#ref };
        self.push(
            ASTType::TupleItemsOpt0(Some(tuple_items_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `TupleItemsOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleItemsOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `TupleItemsOpt /* Option<T>::Some */: Ref;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt_0(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let tuple_items_opt_0_built = TupleItemsOpt { r#ref };
        self.push(
            ASTType::TupleItemsOpt(Some(tuple_items_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `TupleItemsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn tuple_items_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TupleItemsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `Skip: /&\[Production; \d+\] = &\[(?s).*/;`
    ///
    #[parol_runtime::function_name::named]
    fn skip(&mut self, skip: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let skip = skip.token()?.clone();
        let skip_built = Skip { skip };
        // Calling user action here
        self.user_grammar.skip(&skip_built)?;
        self.push(ASTType::Skip(skip_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `CommaOpt: CommaOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt(&mut self, _comma_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_opt0 = pop_item!(self, comma_opt0, CommaOpt0, context);
        let comma_opt_built = CommaOpt { comma_opt0 };
        // Calling user action here
        self.user_grammar.comma_opt(&comma_opt_built)?;
        self.push(ASTType::CommaOpt(comma_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `CommaOpt0 /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let comma_opt0_0_built = CommaOpt0 { comma };
        self.push(ASTType::CommaOpt0(Some(comma_opt0_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `CommaOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommaOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `Assign: '=';`
    ///
    #[parol_runtime::function_name::named]
    fn assign(&mut self, assign: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign = assign.token()?.clone();
        let assign_built = Assign { assign };
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `Number: /-?\d+/;`
    ///
    #[parol_runtime::function_name::named]
    fn number(&mut self, number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = number.token()?.clone();
        let number_built = Number { number };
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `Ref: '&';`
    ///
    #[parol_runtime::function_name::named]
    fn r#ref(&mut self, r#ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = r#ref.token()?.clone();
        let r#ref_built = Ref { r#ref };
        // Calling user action here
        self.user_grammar.r#ref(&r#ref_built)?;
        self.push(ASTType::Ref(r#ref_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `Arrow: '=>';`
    ///
    #[parol_runtime::function_name::named]
    fn arrow(&mut self, arrow: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let arrow = arrow.token()?.clone();
        let arrow_built = Arrow { arrow };
        // Calling user action here
        self.user_grammar.arrow(&arrow_built)?;
        self.push(ASTType::Arrow(arrow_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `Semicolon: ';';`
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(&mut self, semicolon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token()?.clone();
        let semicolon_built = Semicolon { semicolon };
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `Comma: ',';`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token()?.clone();
        let comma_built = Comma { comma };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `String: QuotedString;`
    ///
    #[parol_runtime::function_name::named]
    fn string_0(&mut self, _quoted_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_string = pop_item!(self, quoted_string, QuotedString, context);
        let string_0_built = StringQuotedString { quoted_string };
        let string_0_built = String::QuotedString(string_0_built);
        // Calling user action here
        self.user_grammar.string(&string_0_built)?;
        self.push(ASTType::String(string_0_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `String: RawString;`
    ///
    #[parol_runtime::function_name::named]
    fn string_1(&mut self, _raw_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string = pop_item!(self, raw_string, RawString, context);
        let string_1_built = StringRawString { raw_string };
        let string_1_built = String::RawString(string_1_built);
        // Calling user action here
        self.user_grammar.string(&string_1_built)?;
        self.push(ASTType::String(string_1_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `String: RawString1;`
    ///
    #[parol_runtime::function_name::named]
    fn string_2(&mut self, _raw_string1: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1 = pop_item!(self, raw_string1, RawString1, context);
        let string_2_built = StringRawString1 { raw_string1 };
        let string_2_built = String::RawString1(string_2_built);
        // Calling user action here
        self.user_grammar.string(&string_2_built)?;
        self.push(ASTType::String(string_2_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `String: RawString2;`
    ///
    #[parol_runtime::function_name::named]
    fn string_3(&mut self, _raw_string2: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2 = pop_item!(self, raw_string2, RawString2, context);
        let string_3_built = StringRawString2 { raw_string2 };
        let string_3_built = String::RawString2(string_3_built);
        // Calling user action here
        self.user_grammar.string(&string_3_built)?;
        self.push(ASTType::String(string_3_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `String: RawString3;`
    ///
    #[parol_runtime::function_name::named]
    fn string_4(&mut self, _raw_string3: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3 = pop_item!(self, raw_string3, RawString3, context);
        let string_4_built = StringRawString3 { raw_string3 };
        let string_4_built = String::RawString3(string_4_built);
        // Calling user action here
        self.user_grammar.string(&string_4_built)?;
        self.push(ASTType::String(string_4_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `QuotedString: /"([^"]|\\")*"/;`
    ///
    #[parol_runtime::function_name::named]
    fn quoted_string(&mut self, quoted_string: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quoted_string = quoted_string.token()?.clone();
        let quoted_string_built = QuotedString { quoted_string };
        // Calling user action here
        self.user_grammar.quoted_string(&quoted_string_built)?;
        self.push(ASTType::QuotedString(quoted_string_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `RawStringStart: /r"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string_start(&mut self, raw_string_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_start = raw_string_start.token()?.clone();
        let raw_string_start_built = RawStringStart { raw_string_start };
        // Calling user action here
        self.user_grammar
            .raw_string_start(&raw_string_start_built)?;
        self.push(ASTType::RawStringStart(raw_string_start_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `RawStringEnd: <RAW_STRING>/"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string_end(&mut self, raw_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_end = raw_string_end.token()?.clone();
        let raw_string_end_built = RawStringEnd { raw_string_end };
        // Calling user action here
        self.user_grammar.raw_string_end(&raw_string_end_built)?;
        self.push(ASTType::RawStringEnd(raw_string_end_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `RawStringContent: <RAW_STRING>/([^"]|\\")*/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string_content(&mut self, raw_string_content: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_content = raw_string_content.token()?.clone();
        let raw_string_content_built = RawStringContent { raw_string_content };
        // Calling user action here
        self.user_grammar
            .raw_string_content(&raw_string_content_built)?;
        self.push(ASTType::RawStringContent(raw_string_content_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `RawString: RawStringStart^ /* Clipped */ RawStringContent@strng RawStringEnd^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string(
        &mut self,
        _raw_string_start: &ParseTreeType<'t>,
        _strng: &ParseTreeType<'t>,
        _raw_string_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let strng = pop_item!(self, strng, RawStringContent, context);
        self.pop(context);
        let raw_string_built = RawString { strng };
        // Calling user action here
        self.user_grammar.raw_string(&raw_string_built)?;
        self.push(ASTType::RawString(raw_string_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `RawString1Start: /r#"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_start(&mut self, raw_string1_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1_start = raw_string1_start.token()?.clone();
        let raw_string1_start_built = RawString1Start { raw_string1_start };
        // Calling user action here
        self.user_grammar
            .raw_string1_start(&raw_string1_start_built)?;
        self.push(ASTType::RawString1Start(raw_string1_start_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `RawString1End: <RAW_STRING1>/"#/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_end(&mut self, raw_string1_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1_end = raw_string1_end.token()?.clone();
        let raw_string1_end_built = RawString1End { raw_string1_end };
        // Calling user action here
        self.user_grammar.raw_string1_end(&raw_string1_end_built)?;
        self.push(ASTType::RawString1End(raw_string1_end_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `RawStringContentNoQuotes: <RAW_STRING1>/[^"]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string_content_no_quotes(
        &mut self,
        raw_string_content_no_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_content_no_quotes = raw_string_content_no_quotes.token()?.clone();
        let raw_string_content_no_quotes_built = RawStringContentNoQuotes {
            raw_string_content_no_quotes,
        };
        // Calling user action here
        self.user_grammar
            .raw_string_content_no_quotes(&raw_string_content_no_quotes_built)?;
        self.push(
            ASTType::RawStringContentNoQuotes(raw_string_content_no_quotes_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `RawString1ContentQuotes: <RAW_STRING1>/"/ ?! /#/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content_quotes(&mut self, raw_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_end = raw_string_end.token()?.clone();
        let raw_string1_content_quotes_built = RawString1ContentQuotes { raw_string_end };
        // Calling user action here
        self.user_grammar
            .raw_string1_content_quotes(&raw_string1_content_quotes_built)?;
        self.push(
            ASTType::RawString1ContentQuotes(raw_string1_content_quotes_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `RawString1Content: RawString1ContentList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content(&mut self, _raw_string1_content_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1_content_list = pop_and_reverse_item!(
            self,
            raw_string1_content_list,
            RawString1ContentList,
            context
        );
        let raw_string1_content_built = RawString1Content {
            raw_string1_content_list,
        };
        // Calling user action here
        self.user_grammar
            .raw_string1_content(&raw_string1_content_built)?;
        self.push(
            ASTType::RawString1Content(raw_string1_content_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `RawString1ContentList /* Vec<T>::Push */: RawString1ContentListGroup RawString1ContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content_list_0(
        &mut self,
        _raw_string1_content_list_group: &ParseTreeType<'t>,
        _raw_string1_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut raw_string1_content_list = pop_item!(
            self,
            raw_string1_content_list,
            RawString1ContentList,
            context
        );
        let raw_string1_content_list_group = pop_item!(
            self,
            raw_string1_content_list_group,
            RawString1ContentListGroup,
            context
        );
        let raw_string1_content_list_0_built = RawString1ContentList {
            raw_string1_content_list_group,
        };
        // Add an element to the vector
        raw_string1_content_list.push(raw_string1_content_list_0_built);
        self.push(
            ASTType::RawString1ContentList(raw_string1_content_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `RawString1ContentListGroup: RawStringContentNoQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content_list_group_0(
        &mut self,
        _raw_string_content_no_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_content_no_quotes = pop_item!(
            self,
            raw_string_content_no_quotes,
            RawStringContentNoQuotes,
            context
        );
        let raw_string1_content_list_group_0_built =
            RawString1ContentListGroupRawStringContentNoQuotes {
                raw_string_content_no_quotes,
            };
        let raw_string1_content_list_group_0_built =
            RawString1ContentListGroup::RawStringContentNoQuotes(
                raw_string1_content_list_group_0_built,
            );
        self.push(
            ASTType::RawString1ContentListGroup(raw_string1_content_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `RawString1ContentListGroup: RawString1ContentQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content_list_group_1(
        &mut self,
        _raw_string1_content_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1_content_quotes = pop_item!(
            self,
            raw_string1_content_quotes,
            RawString1ContentQuotes,
            context
        );
        let raw_string1_content_list_group_1_built =
            RawString1ContentListGroupRawString1ContentQuotes {
                raw_string1_content_quotes,
            };
        let raw_string1_content_list_group_1_built =
            RawString1ContentListGroup::RawString1ContentQuotes(
                raw_string1_content_list_group_1_built,
            );
        self.push(
            ASTType::RawString1ContentListGroup(raw_string1_content_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `RawString1ContentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string1_content_list_1_built = Vec::new();
        self.push(
            ASTType::RawString1ContentList(raw_string1_content_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `RawString1: RawString1Start^ /* Clipped */ RawString1Content@strng RawString1End^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string1(
        &mut self,
        _raw_string1_start: &ParseTreeType<'t>,
        _strng: &ParseTreeType<'t>,
        _raw_string1_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let strng = pop_item!(self, strng, RawString1Content, context);
        self.pop(context);
        let raw_string1_built = RawString1 { strng };
        // Calling user action here
        self.user_grammar.raw_string1(&raw_string1_built)?;
        self.push(ASTType::RawString1(raw_string1_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `RawString2Start: /r##"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_start(&mut self, raw_string2_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2_start = raw_string2_start.token()?.clone();
        let raw_string2_start_built = RawString2Start { raw_string2_start };
        // Calling user action here
        self.user_grammar
            .raw_string2_start(&raw_string2_start_built)?;
        self.push(ASTType::RawString2Start(raw_string2_start_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `RawString2End: <RAW_STRING2>/"##/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_end(&mut self, raw_string2_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2_end = raw_string2_end.token()?.clone();
        let raw_string2_end_built = RawString2End { raw_string2_end };
        // Calling user action here
        self.user_grammar.raw_string2_end(&raw_string2_end_built)?;
        self.push(ASTType::RawString2End(raw_string2_end_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `RawString2ContentQuotes: <RAW_STRING2>/"/ ?! /##/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content_quotes(&mut self, raw_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_end = raw_string_end.token()?.clone();
        let raw_string2_content_quotes_built = RawString2ContentQuotes { raw_string_end };
        // Calling user action here
        self.user_grammar
            .raw_string2_content_quotes(&raw_string2_content_quotes_built)?;
        self.push(
            ASTType::RawString2ContentQuotes(raw_string2_content_quotes_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `RawString2Content: RawString2ContentList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content(&mut self, _raw_string2_content_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2_content_list = pop_and_reverse_item!(
            self,
            raw_string2_content_list,
            RawString2ContentList,
            context
        );
        let raw_string2_content_built = RawString2Content {
            raw_string2_content_list,
        };
        // Calling user action here
        self.user_grammar
            .raw_string2_content(&raw_string2_content_built)?;
        self.push(
            ASTType::RawString2Content(raw_string2_content_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `RawString2ContentList /* Vec<T>::Push */: RawString2ContentListGroup RawString2ContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content_list_0(
        &mut self,
        _raw_string2_content_list_group: &ParseTreeType<'t>,
        _raw_string2_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut raw_string2_content_list = pop_item!(
            self,
            raw_string2_content_list,
            RawString2ContentList,
            context
        );
        let raw_string2_content_list_group = pop_item!(
            self,
            raw_string2_content_list_group,
            RawString2ContentListGroup,
            context
        );
        let raw_string2_content_list_0_built = RawString2ContentList {
            raw_string2_content_list_group,
        };
        // Add an element to the vector
        raw_string2_content_list.push(raw_string2_content_list_0_built);
        self.push(
            ASTType::RawString2ContentList(raw_string2_content_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `RawString2ContentListGroup: RawStringContentNoQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content_list_group_0(
        &mut self,
        _raw_string_content_no_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_content_no_quotes = pop_item!(
            self,
            raw_string_content_no_quotes,
            RawStringContentNoQuotes,
            context
        );
        let raw_string2_content_list_group_0_built =
            RawString2ContentListGroupRawStringContentNoQuotes {
                raw_string_content_no_quotes,
            };
        let raw_string2_content_list_group_0_built =
            RawString2ContentListGroup::RawStringContentNoQuotes(
                raw_string2_content_list_group_0_built,
            );
        self.push(
            ASTType::RawString2ContentListGroup(raw_string2_content_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `RawString2ContentListGroup: RawString2ContentQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content_list_group_1(
        &mut self,
        _raw_string2_content_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2_content_quotes = pop_item!(
            self,
            raw_string2_content_quotes,
            RawString2ContentQuotes,
            context
        );
        let raw_string2_content_list_group_1_built =
            RawString2ContentListGroupRawString2ContentQuotes {
                raw_string2_content_quotes,
            };
        let raw_string2_content_list_group_1_built =
            RawString2ContentListGroup::RawString2ContentQuotes(
                raw_string2_content_list_group_1_built,
            );
        self.push(
            ASTType::RawString2ContentListGroup(raw_string2_content_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `RawString2ContentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string2_content_list_1_built = Vec::new();
        self.push(
            ASTType::RawString2ContentList(raw_string2_content_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `RawString2: RawString2Start^ /* Clipped */ RawString2Content@strng RawString2End^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string2(
        &mut self,
        _raw_string2_start: &ParseTreeType<'t>,
        _strng: &ParseTreeType<'t>,
        _raw_string2_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let strng = pop_item!(self, strng, RawString2Content, context);
        self.pop(context);
        let raw_string2_built = RawString2 { strng };
        // Calling user action here
        self.user_grammar.raw_string2(&raw_string2_built)?;
        self.push(ASTType::RawString2(raw_string2_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `RawString3Start: /r\u{0023}{3}"/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_start(&mut self, raw_string3_start: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3_start = raw_string3_start.token()?.clone();
        let raw_string3_start_built = RawString3Start { raw_string3_start };
        // Calling user action here
        self.user_grammar
            .raw_string3_start(&raw_string3_start_built)?;
        self.push(ASTType::RawString3Start(raw_string3_start_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `RawString3End: <RAW_STRING3>/"\u{0023}{3}/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_end(&mut self, raw_string3_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3_end = raw_string3_end.token()?.clone();
        let raw_string3_end_built = RawString3End { raw_string3_end };
        // Calling user action here
        self.user_grammar.raw_string3_end(&raw_string3_end_built)?;
        self.push(ASTType::RawString3End(raw_string3_end_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `RawString3ContentQuotes: <RAW_STRING3>/"/ ?! /\u{0023}{3}/;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content_quotes(&mut self, raw_string_end: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_end = raw_string_end.token()?.clone();
        let raw_string3_content_quotes_built = RawString3ContentQuotes { raw_string_end };
        // Calling user action here
        self.user_grammar
            .raw_string3_content_quotes(&raw_string3_content_quotes_built)?;
        self.push(
            ASTType::RawString3ContentQuotes(raw_string3_content_quotes_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `RawString3Content: RawString3ContentList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content(&mut self, _raw_string3_content_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3_content_list = pop_and_reverse_item!(
            self,
            raw_string3_content_list,
            RawString3ContentList,
            context
        );
        let raw_string3_content_built = RawString3Content {
            raw_string3_content_list,
        };
        // Calling user action here
        self.user_grammar
            .raw_string3_content(&raw_string3_content_built)?;
        self.push(
            ASTType::RawString3Content(raw_string3_content_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `RawString3ContentList /* Vec<T>::Push */: RawString3ContentListGroup RawString3ContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content_list_0(
        &mut self,
        _raw_string3_content_list_group: &ParseTreeType<'t>,
        _raw_string3_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut raw_string3_content_list = pop_item!(
            self,
            raw_string3_content_list,
            RawString3ContentList,
            context
        );
        let raw_string3_content_list_group = pop_item!(
            self,
            raw_string3_content_list_group,
            RawString3ContentListGroup,
            context
        );
        let raw_string3_content_list_0_built = RawString3ContentList {
            raw_string3_content_list_group,
        };
        // Add an element to the vector
        raw_string3_content_list.push(raw_string3_content_list_0_built);
        self.push(
            ASTType::RawString3ContentList(raw_string3_content_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `RawString3ContentListGroup: RawStringContentNoQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content_list_group_0(
        &mut self,
        _raw_string_content_no_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string_content_no_quotes = pop_item!(
            self,
            raw_string_content_no_quotes,
            RawStringContentNoQuotes,
            context
        );
        let raw_string3_content_list_group_0_built =
            RawString3ContentListGroupRawStringContentNoQuotes {
                raw_string_content_no_quotes,
            };
        let raw_string3_content_list_group_0_built =
            RawString3ContentListGroup::RawStringContentNoQuotes(
                raw_string3_content_list_group_0_built,
            );
        self.push(
            ASTType::RawString3ContentListGroup(raw_string3_content_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `RawString3ContentListGroup: RawString3ContentQuotes;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content_list_group_1(
        &mut self,
        _raw_string3_content_quotes: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3_content_quotes = pop_item!(
            self,
            raw_string3_content_quotes,
            RawString3ContentQuotes,
            context
        );
        let raw_string3_content_list_group_1_built =
            RawString3ContentListGroupRawString3ContentQuotes {
                raw_string3_content_quotes,
            };
        let raw_string3_content_list_group_1_built =
            RawString3ContentListGroup::RawString3ContentQuotes(
                raw_string3_content_list_group_1_built,
            );
        self.push(
            ASTType::RawString3ContentListGroup(raw_string3_content_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `RawString3ContentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let raw_string3_content_list_1_built = Vec::new();
        self.push(
            ASTType::RawString3ContentList(raw_string3_content_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `RawString3: RawString3Start^ /* Clipped */ RawString3Content@strng RawString3End^ /* Clipped */;`
    ///
    #[parol_runtime::function_name::named]
    fn raw_string3(
        &mut self,
        _raw_string3_start: &ParseTreeType<'t>,
        _strng: &ParseTreeType<'t>,
        _raw_string3_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.pop(context);
        let strng = pop_item!(self, strng, RawString3Content, context);
        self.pop(context);
        let raw_string3_built = RawString3 { strng };
        // Calling user action here
        self.user_grammar.raw_string3(&raw_string3_built)?;
        self.push(ASTType::RawString3(raw_string3_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `Ident: /[a-zA-Z_][a-zA-Z0-9_]*/;`
    ///
    #[parol_runtime::function_name::named]
    fn ident(&mut self, ident: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ident = ident.token()?.clone();
        let ident_built = Ident { ident };
        // Calling user action here
        self.user_grammar.ident(&ident_built)?;
        self.push(ASTType::Ident(ident_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `DoubleColon: '::';`
    ///
    #[parol_runtime::function_name::named]
    fn double_colon(&mut self, double_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let double_colon = double_colon.token()?.clone();
        let double_colon_built = DoubleColon { double_colon };
        // Calling user action here
        self.user_grammar.double_colon(&double_colon_built)?;
        self.push(ASTType::DoubleColon(double_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `Colon: ':';`
    ///
    #[parol_runtime::function_name::named]
    fn colon(&mut self, colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token()?.clone();
        let colon_built = Colon { colon };
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `LBrace: '{';`
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(&mut self, l_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token()?.clone();
        let l_brace_built = LBrace { l_brace };
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `RBrace: '}';`
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(&mut self, r_brace: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = r_brace.token()?.clone();
        let r_brace_built = RBrace { r_brace };
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `LBracket: '[';`
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(&mut self, l_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token()?.clone();
        let l_bracket_built = LBracket { l_bracket };
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `RBracket: ']';`
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(&mut self, r_bracket: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = r_bracket.token()?.clone();
        let r_bracket_built = RBracket { r_bracket };
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `LParen: '(';`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, l_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token()?.clone();
        let l_paren_built = LParen { l_paren };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `RParen: ')';`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, r_paren: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token()?.clone();
        let r_paren_built = RParen { r_paren };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `Hash: /#/;`
    ///
    #[parol_runtime::function_name::named]
    fn hash(&mut self, hash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token()?.clone();
        let hash_built = Hash { hash };
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `LT: '<';`
    ///
    #[parol_runtime::function_name::named]
    fn l_t(&mut self, l_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token()?.clone();
        let l_t_built = LT { l_t };
        // Calling user action here
        self.user_grammar.l_t(&l_t_built)?;
        self.push(ASTType::LT(l_t_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `GT: '>';`
    ///
    #[parol_runtime::function_name::named]
    fn g_t(&mut self, g_t: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t.token()?.clone();
        let g_t_built = GT { g_t };
        // Calling user action here
        self.user_grammar.g_t(&g_t_built)?;
        self.push(ASTType::GT(g_t_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for LaDfa2DotGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item LaDfa2DotGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.la_dfa2_dot(&children[0]),
            1 => self.la_dfa2_dot_list_0(&children[0], &children[1], &children[2]),
            2 => self.la_dfa2_dot_list_1(),
            3 => self.attribute_opt(&children[0]),
            4 => self.attribute_opt0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            5 => self.attribute_opt0_1(),
            6 => self.attribute_arg_opt(&children[0]),
            7 => self.attribute_arg_opt0_0(&children[0], &children[1], &children[2]),
            8 => self.attribute_arg_opt0_1(),
            9 => self.item_0(&children[0]),
            10 => self.item_1(&children[0]),
            11 => self.item_2(&children[0]),
            12 => self.use_statement(&children[0], &children[1], &children[2]),
            13 => self.qualified_ident(&children[0], &children[1]),
            14 => self.qualified_ident_list_0(&children[0], &children[1], &children[2]),
            15 => self.qualified_ident_list_1(),
            16 => self.scoped_qualified_ident(&children[0], &children[1]),
            17 => self.scoped_qualified_ident_opt_0(&children[0], &children[1]),
            18 => self.scoped_qualified_ident_opt_1(),
            19 => self.scoped_list(&children[0], &children[1], &children[2], &children[3]),
            20 => self.scoped_list_items(&children[0], &children[1]),
            21 => self.scoped_list_items_list_0(&children[0], &children[1], &children[2]),
            22 => self.scoped_list_items_list_1(),
            23 => self.const_declaration_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            24 => self.const_declaration_1(&children[0], &children[1]),
            25 => self.const_preamble(&children[0], &children[1], &children[2]),
            26 => self.const_qualifier_0(&children[0], &children[1]),
            27 => self.const_qualifier_1(&children[0]),
            28 => self.const_qualifier_opt_0(&children[0]),
            29 => self.const_qualifier_opt_1(),
            30 => self.const_name(&children[0]),
            31 => self.const_val_0(&children[0]),
            32 => self.const_val_1(&children[0]),
            33 => self.const_val_2(&children[0]),
            34 => self.const_val_3(&children[0]),
            35 => self.const_val_4(&children[0]),
            36 => self.array_val(&children[0], &children[1], &children[2], &children[3]),
            37 => self.array_val_opt_0(&children[0], &children[1]),
            38 => self.array_val_opt_1(),
            39 => self.const_val_list(&children[0], &children[1]),
            40 => self.const_val_list_list_0(&children[0], &children[1], &children[2]),
            41 => self.const_val_list_list_1(),
            42 => self.tuple_val(&children[0], &children[1], &children[2]),
            43 => self.tuple_val_opt_0(&children[0], &children[1]),
            44 => self.tuple_val_opt_1(),
            45 => self.qualified_val(&children[0], &children[1]),
            46 => self.qualified_val_opt_0(&children[0]),
            47 => self.qualified_val_opt_1(),
            48 => self.struct_or_tuple_val_0(&children[0]),
            49 => self.struct_or_tuple_val_1(&children[0]),
            50 => self.struct_val(&children[0], &children[1], &children[2]),
            51 => self.struct_val_opt_0(&children[0], &children[1]),
            52 => self.struct_val_opt_1(),
            53 => self.member_values(&children[0], &children[1]),
            54 => self.member_values_list_0(&children[0], &children[1], &children[2]),
            55 => self.member_values_list_1(),
            56 => self.member_value(&children[0], &children[1], &children[2]),
            57 => self.tuple_struct_val(&children[0]),
            58 => self.scanner_macro(&children[0], &children[1], &children[2], &children[3]),
            59 => self.scanner_macro_body(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            60 => self.scanner_macro_body_list_0(&children[0], &children[1]),
            61 => self.scanner_macro_body_list_1(),
            62 => self.scanner_macro_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            63 => self.scanner_macro_item_list_0(&children[0], &children[1]),
            64 => self.scanner_macro_item_list_group_0(&children[0]),
            65 => self.scanner_macro_item_list_group_1(&children[0]),
            66 => self.scanner_macro_item_list_1(),
            67 => self.token_definition(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            68 => self.token_definition_opt_0(&children[0]),
            69 => self.token_definition_opt_1(),
            70 => self.mode_transition(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            71 => self.lookahead_expression(&children[0], &children[1], &children[2], &children[3]),
            72 => self.lookahead_expression_opt_0(&children[0]),
            73 => self.lookahead_expression_opt_1(),
            74 => self.type_spec_0(&children[0]),
            75 => self.type_spec_1(&children[0]),
            76 => self.type_spec_2(&children[0]),
            77 => self.type_spec_3(&children[0]),
            78 => self.array_type(&children[0], &children[1], &children[2], &children[3]),
            79 => self.array_type_spec(&children[0], &children[1], &children[2], &children[3]),
            80 => self.array_type_spec_opt_0(&children[0]),
            81 => self.array_type_spec_opt_1(),
            82 => self.array_element_type_0(&children[0]),
            83 => self.array_element_type_1(&children[0]),
            84 => self.option_type(&children[0], &children[1], &children[2], &children[3]),
            85 => self.tuple(&children[0], &children[1], &children[2], &children[3]),
            86 => self.tuple_type(&children[0], &children[1], &children[2], &children[3]),
            87 => self.tuple_items(&children[0], &children[1], &children[2]),
            88 => self.tuple_items_list_0(&children[0], &children[1], &children[2], &children[3]),
            89 => self.tuple_items_list_1(),
            90 => self.tuple_items_opt0_0(&children[0]),
            91 => self.tuple_items_opt0_1(),
            92 => self.tuple_items_opt_0(&children[0]),
            93 => self.tuple_items_opt_1(),
            94 => self.skip(&children[0]),
            95 => self.comma_opt(&children[0]),
            96 => self.comma_opt0_0(&children[0]),
            97 => self.comma_opt0_1(),
            98 => self.assign(&children[0]),
            99 => self.number(&children[0]),
            100 => self.r#ref(&children[0]),
            101 => self.arrow(&children[0]),
            102 => self.semicolon(&children[0]),
            103 => self.comma(&children[0]),
            104 => self.string_0(&children[0]),
            105 => self.string_1(&children[0]),
            106 => self.string_2(&children[0]),
            107 => self.string_3(&children[0]),
            108 => self.string_4(&children[0]),
            109 => self.quoted_string(&children[0]),
            110 => self.raw_string_start(&children[0]),
            111 => self.raw_string_end(&children[0]),
            112 => self.raw_string_content(&children[0]),
            113 => self.raw_string(&children[0], &children[1], &children[2]),
            114 => self.raw_string1_start(&children[0]),
            115 => self.raw_string1_end(&children[0]),
            116 => self.raw_string_content_no_quotes(&children[0]),
            117 => self.raw_string1_content_quotes(&children[0]),
            118 => self.raw_string1_content(&children[0]),
            119 => self.raw_string1_content_list_0(&children[0], &children[1]),
            120 => self.raw_string1_content_list_group_0(&children[0]),
            121 => self.raw_string1_content_list_group_1(&children[0]),
            122 => self.raw_string1_content_list_1(),
            123 => self.raw_string1(&children[0], &children[1], &children[2]),
            124 => self.raw_string2_start(&children[0]),
            125 => self.raw_string2_end(&children[0]),
            126 => self.raw_string2_content_quotes(&children[0]),
            127 => self.raw_string2_content(&children[0]),
            128 => self.raw_string2_content_list_0(&children[0], &children[1]),
            129 => self.raw_string2_content_list_group_0(&children[0]),
            130 => self.raw_string2_content_list_group_1(&children[0]),
            131 => self.raw_string2_content_list_1(),
            132 => self.raw_string2(&children[0], &children[1], &children[2]),
            133 => self.raw_string3_start(&children[0]),
            134 => self.raw_string3_end(&children[0]),
            135 => self.raw_string3_content_quotes(&children[0]),
            136 => self.raw_string3_content(&children[0]),
            137 => self.raw_string3_content_list_0(&children[0], &children[1]),
            138 => self.raw_string3_content_list_group_0(&children[0]),
            139 => self.raw_string3_content_list_group_1(&children[0]),
            140 => self.raw_string3_content_list_1(),
            141 => self.raw_string3(&children[0], &children[1], &children[2]),
            142 => self.ident(&children[0]),
            143 => self.double_colon(&children[0]),
            144 => self.colon(&children[0]),
            145 => self.l_brace(&children[0]),
            146 => self.r_brace(&children[0]),
            147 => self.l_bracket(&children[0]),
            148 => self.r_bracket(&children[0]),
            149 => self.l_paren(&children[0]),
            150 => self.r_paren(&children[0]),
            151 => self.hash(&children[0]),
            152 => self.l_t(&children[0]),
            153 => self.g_t(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {prod_num}"
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
