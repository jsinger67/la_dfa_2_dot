// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait LaDfa2DotGrammarTrait<'t> {
    /// Semantic action for non-terminal 'LaDfa2Dot'
    fn la_dfa2_dot(&mut self, _arg: &LaDfa2Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parts'
    fn parts(&mut self, _arg: &Parts<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommentStart'
    fn comment_start(&mut self, _arg: &CommentStart) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommentEnd'
    fn comment_end(&mut self, _arg: &CommentEnd) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NamingComment'
    fn naming_comment(&mut self, _arg: &NamingComment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prod0'
    fn prod0(&mut self, _arg: &Prod0<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransitionsPrefix'
    fn transitions_prefix(&mut self, _arg: &TransitionsPrefix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransitionsPostfix'
    fn transitions_postfix(&mut self, _arg: &TransitionsPostfix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Transitions'
    fn transitions(&mut self, _arg: &Transitions<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransList'
    fn trans_list(&mut self, _arg: &TransList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntryPrefix'
    fn trans_entry_prefix(&mut self, _arg: &TransEntryPrefix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntryPostfix'
    fn trans_entry_postfix(&mut self, _arg: &TransEntryPostfix) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntryValue'
    fn trans_entry_value(&mut self, _arg: &TransEntryValue<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntry'
    fn trans_entry(&mut self, _arg: &TransEntry<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'K'
    fn k(&mut self, _arg: &K<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProdNum'
    fn prod_num(&mut self, _arg: &ProdNum<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NtName'
    fn nt_name(&mut self, _arg: &NtName<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dash'
    fn dash(&mut self, _arg: &Dash<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaOpt'
    fn comma_opt(&mut self, _arg: &CommaOpt) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal CommaOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaOpt {
    pub comma_opt0: Option<Box<CommaOpt0>>,
}

///
/// Type derived for non-terminal CommaOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaOpt0 {}

///
/// Type derived for non-terminal CommentEnd
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentEnd {}

///
/// Type derived for non-terminal CommentStart
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentStart {}

///
/// Type derived for non-terminal Dash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dash<'t> {
    pub dash: Token<'t>, /* - */
}

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* -?\d+ */
}

///
/// Type derived for non-terminal K
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct K<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal LaDfa2Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LaDfa2Dot<'t> {
    pub naming_comment: Box<NamingComment<'t>>,
    pub parts: Box<Parts<'t>>,
}

///
/// Type derived for non-terminal NamingComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NamingComment<'t> {
    pub prod_num: Box<ProdNum<'t>>,
    pub nt_name: Box<NtName<'t>>,
}

///
/// Type derived for non-terminal NtName
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NtName<'t> {
    pub nt_name: Token<'t>, /* "\w+?" */
}

///
/// Type derived for non-terminal Parts
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parts<'t> {
    pub prod0: Box<Prod0<'t>>,
    pub transitions: Box<Transitions<'t>>,
    pub k: Box<K<'t>>,
}

///
/// Type derived for non-terminal Prod0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prod0<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal ProdNum
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ProdNum<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal TransEntry
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntry<'t> {
    pub trans_entry_prefix: Box<TransEntryPrefix>,
    pub trans_entry_value: Box<TransEntryValue<'t>>,
    pub trans_entry_value0: Box<TransEntryValue<'t>>,
    pub trans_entry_value1: Box<TransEntryValue<'t>>,
    pub trans_entry_value2: Box<TransEntryValue<'t>>,
}

///
/// Type derived for non-terminal TransEntryPostfix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntryPostfix {}

///
/// Type derived for non-terminal TransEntryPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntryPrefix {}

///
/// Type derived for non-terminal TransEntryValue
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntryValue<'t> {
    pub integer: Box<Integer<'t>>,
}

///
/// Type derived for non-terminal TransList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransList<'t> {
    pub trans_list_list: Vec<TransListList<'t>>,
}

///
/// Type derived for non-terminal TransListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransListList<'t> {
    pub trans_entry: Box<TransEntry<'t>>,
}

///
/// Type derived for non-terminal Transitions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Transitions<'t> {
    pub trans_list: Box<TransList<'t>>,
}

///
/// Type derived for non-terminal TransitionsPostfix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransitionsPostfix {}

///
/// Type derived for non-terminal TransitionsPrefix
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransitionsPrefix {}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    CommaOpt(CommaOpt),
    CommaOpt0(Option<Box<CommaOpt0>>),
    CommentEnd(CommentEnd),
    CommentStart(CommentStart),
    Dash(Dash<'t>),
    Integer(Integer<'t>),
    K(K<'t>),
    LaDfa2Dot(LaDfa2Dot<'t>),
    NamingComment(NamingComment<'t>),
    NtName(NtName<'t>),
    Parts(Parts<'t>),
    Prod0(Prod0<'t>),
    ProdNum(ProdNum<'t>),
    TransEntry(TransEntry<'t>),
    TransEntryPostfix(TransEntryPostfix),
    TransEntryPrefix(TransEntryPrefix),
    TransEntryValue(TransEntryValue<'t>),
    TransList(TransList<'t>),
    TransListList(Vec<TransListList<'t>>),
    Transitions(Transitions<'t>),
    TransitionsPostfix(TransitionsPostfix),
    TransitionsPrefix(TransitionsPrefix),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct LaDfa2DotGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `LaDfa2DotGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> LaDfa2DotGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// LaDfa2Dot: NamingComment 'LookaheadDFA'^ /* Clipped */ Parts;
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot(
        &mut self,
        _naming_comment: &ParseTreeType<'t>,
        _lookahead_d_f_a: &ParseTreeType<'t>,
        _parts: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts = pop_item!(self, parts, Parts, context);
        let naming_comment = pop_item!(self, naming_comment, NamingComment, context);
        let la_dfa2_dot_built = LaDfa2Dot {
            naming_comment: Box::new(naming_comment),
            // Ignore clipped member 'lookahead_d_f_a'
            parts: Box::new(parts),
        };
        // Calling user action here
        self.user_grammar.la_dfa2_dot(&la_dfa2_dot_built)?;
        self.push(ASTType::LaDfa2Dot(la_dfa2_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Parts: '{'^ /* Clipped */ Prod0 Transitions K '}'^ /* Clipped */ CommaOpt^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn parts(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _prod0: &ParseTreeType<'t>,
        _transitions: &ParseTreeType<'t>,
        _k: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'comma_opt'
        self.pop(context);
        let k = pop_item!(self, k, K, context);
        let transitions = pop_item!(self, transitions, Transitions, context);
        let prod0 = pop_item!(self, prod0, Prod0, context);
        let parts_built = Parts {
            // Ignore clipped member 'l_brace'
            prod0: Box::new(prod0),
            transitions: Box::new(transitions),
            k: Box::new(k),
            // Ignore clipped member 'r_brace'
            // Ignore clipped member 'comma_opt'
        };
        // Calling user action here
        self.user_grammar.parts(&parts_built)?;
        self.push(ASTType::Parts(parts_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// CommentStart: '/'^ /* Clipped */ '*'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn comment_start(
        &mut self,
        _slash: &ParseTreeType<'t>,
        _star: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment_start_built = CommentStart {
        // Ignore clipped member 'slash'
        // Ignore clipped member 'star'
        };
        // Calling user action here
        self.user_grammar.comment_start(&comment_start_built)?;
        self.push(ASTType::CommentStart(comment_start_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// CommentEnd: '*'^ /* Clipped */ '/'^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn comment_end(&mut self, _star: &ParseTreeType<'t>, _slash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment_end_built = CommentEnd {
        // Ignore clipped member 'star'
        // Ignore clipped member 'slash'
        };
        // Calling user action here
        self.user_grammar.comment_end(&comment_end_built)?;
        self.push(ASTType::CommentEnd(comment_end_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// NamingComment: CommentStart^ /* Clipped */ ProdNum Dash^ /* Clipped */ NtName CommentEnd^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn naming_comment(
        &mut self,
        _comment_start: &ParseTreeType<'t>,
        _prod_num: &ParseTreeType<'t>,
        _dash: &ParseTreeType<'t>,
        _nt_name: &ParseTreeType<'t>,
        _comment_end: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'comment_end'
        self.pop(context);
        let nt_name = pop_item!(self, nt_name, NtName, context);
        // Ignore clipped member 'dash'
        self.pop(context);
        let prod_num = pop_item!(self, prod_num, ProdNum, context);
        // Ignore clipped member 'comment_start'
        self.pop(context);
        let naming_comment_built = NamingComment {
            // Ignore clipped member 'comment_start'
            prod_num: Box::new(prod_num),
            // Ignore clipped member 'dash'
            nt_name: Box::new(nt_name),
            // Ignore clipped member 'comment_end'
        };
        // Calling user action here
        self.user_grammar.naming_comment(&naming_comment_built)?;
        self.push(ASTType::NamingComment(naming_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Prod0: 'prod0'^ /* Clipped */ ':'^ /* Clipped */ Integer ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn prod0(
        &mut self,
        _prod0: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let prod0_built = Prod0 {
            // Ignore clipped member 'prod0'
            // Ignore clipped member 'colon'
            integer: Box::new(integer),
            // Ignore clipped member 'comma'
        };
        // Calling user action here
        self.user_grammar.prod0(&prod0_built)?;
        self.push(ASTType::Prod0(prod0_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// TransitionsPrefix: 'transitions'^ /* Clipped */ ':'^ /* Clipped */ '&'^ /* Clipped */ '['^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_prefix(
        &mut self,
        _transitions: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _amp: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let transitions_prefix_built = TransitionsPrefix {
        // Ignore clipped member 'transitions'
        // Ignore clipped member 'colon'
        // Ignore clipped member 'amp'
        // Ignore clipped member 'l_bracket'
        };
        // Calling user action here
        self.user_grammar
            .transitions_prefix(&transitions_prefix_built)?;
        self.push(
            ASTType::TransitionsPrefix(transitions_prefix_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// TransitionsPostfix: ']'^ /* Clipped */ CommaOpt^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_postfix(
        &mut self,
        _r_bracket: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'comma_opt'
        self.pop(context);
        let transitions_postfix_built = TransitionsPostfix {
        // Ignore clipped member 'r_bracket'
        // Ignore clipped member 'comma_opt'
        };
        // Calling user action here
        self.user_grammar
            .transitions_postfix(&transitions_postfix_built)?;
        self.push(
            ASTType::TransitionsPostfix(transitions_postfix_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Transitions: TransitionsPrefix^ /* Clipped */ TransList TransitionsPostfix^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions(
        &mut self,
        _transitions_prefix: &ParseTreeType<'t>,
        _trans_list: &ParseTreeType<'t>,
        _transitions_postfix: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'transitions_postfix'
        self.pop(context);
        let trans_list = pop_item!(self, trans_list, TransList, context);
        // Ignore clipped member 'transitions_prefix'
        self.pop(context);
        let transitions_built = Transitions {
            // Ignore clipped member 'transitions_prefix'
            trans_list: Box::new(trans_list),
            // Ignore clipped member 'transitions_postfix'
        };
        // Calling user action here
        self.user_grammar.transitions(&transitions_built)?;
        self.push(ASTType::Transitions(transitions_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// TransList: TransListList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list(&mut self, _trans_list_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list = pop_and_reverse_item!(self, trans_list_list, TransListList, context);
        let trans_list_built = TransList { trans_list_list };
        // Calling user action here
        self.user_grammar.trans_list(&trans_list_built)?;
        self.push(ASTType::TransList(trans_list_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// TransListList /* `Vec<T>::Push` */: TransEntry TransListList;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_0(
        &mut self,
        _trans_entry: &ParseTreeType<'t>,
        _trans_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut trans_list_list = pop_item!(self, trans_list_list, TransListList, context);
        let trans_entry = pop_item!(self, trans_entry, TransEntry, context);
        let trans_list_list_0_built = TransListList {
            trans_entry: Box::new(trans_entry),
        };
        // Add an element to the vector
        trans_list_list.push(trans_list_list_0_built);
        self.push(ASTType::TransListList(trans_list_list), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// TransListList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list_1_built = Vec::new();
        self.push(ASTType::TransListList(trans_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// TransEntryPrefix: 'Trans'^ /* Clipped */ '('^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry_prefix(
        &mut self,
        _trans: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_entry_prefix_built = TransEntryPrefix {
        // Ignore clipped member 'trans'
        // Ignore clipped member 'l_paren'
        };
        // Calling user action here
        self.user_grammar
            .trans_entry_prefix(&trans_entry_prefix_built)?;
        self.push(ASTType::TransEntryPrefix(trans_entry_prefix_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// TransEntryPostfix: ')'^ /* Clipped */ ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry_postfix(
        &mut self,
        _r_paren: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_entry_postfix_built = TransEntryPostfix {
        // Ignore clipped member 'r_paren'
        // Ignore clipped member 'comma'
        };
        // Calling user action here
        self.user_grammar
            .trans_entry_postfix(&trans_entry_postfix_built)?;
        self.push(
            ASTType::TransEntryPostfix(trans_entry_postfix_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// TransEntryValue: Integer CommaOpt^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry_value(
        &mut self,
        _integer: &ParseTreeType<'t>,
        _comma_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'comma_opt'
        self.pop(context);
        let integer = pop_item!(self, integer, Integer, context);
        let trans_entry_value_built = TransEntryValue {
            integer: Box::new(integer),
            // Ignore clipped member 'comma_opt'
        };
        // Calling user action here
        self.user_grammar
            .trans_entry_value(&trans_entry_value_built)?;
        self.push(ASTType::TransEntryValue(trans_entry_value_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// TransEntry: TransEntryPrefix TransEntryValue TransEntryValue TransEntryValue TransEntryValue TransEntryPostfix^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry(
        &mut self,
        _trans_entry_prefix: &ParseTreeType<'t>,
        _trans_entry_value: &ParseTreeType<'t>,
        _trans_entry_value0: &ParseTreeType<'t>,
        _trans_entry_value1: &ParseTreeType<'t>,
        _trans_entry_value2: &ParseTreeType<'t>,
        _trans_entry_postfix: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'trans_entry_postfix'
        self.pop(context);
        let trans_entry_value2 = pop_item!(self, trans_entry_value2, TransEntryValue, context);
        let trans_entry_value1 = pop_item!(self, trans_entry_value1, TransEntryValue, context);
        let trans_entry_value0 = pop_item!(self, trans_entry_value0, TransEntryValue, context);
        let trans_entry_value = pop_item!(self, trans_entry_value, TransEntryValue, context);
        let trans_entry_prefix = pop_item!(self, trans_entry_prefix, TransEntryPrefix, context);
        let trans_entry_built = TransEntry {
            trans_entry_prefix: Box::new(trans_entry_prefix),
            trans_entry_value: Box::new(trans_entry_value),
            trans_entry_value0: Box::new(trans_entry_value0),
            trans_entry_value1: Box::new(trans_entry_value1),
            trans_entry_value2: Box::new(trans_entry_value2),
            // Ignore clipped member 'trans_entry_postfix'
        };
        // Calling user action here
        self.user_grammar.trans_entry(&trans_entry_built)?;
        self.push(ASTType::TransEntry(trans_entry_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// K: 'k'^ /* Clipped */ ':'^ /* Clipped */ Integer ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn k(
        &mut self,
        _k: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let k_built = K {
            // Ignore clipped member 'k'
            // Ignore clipped member 'colon'
            integer: Box::new(integer),
            // Ignore clipped member 'comma'
        };
        // Calling user action here
        self.user_grammar.k(&k_built)?;
        self.push(ASTType::K(k_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// ProdNum: Integer;
    ///
    #[parol_runtime::function_name::named]
    fn prod_num(&mut self, _integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = pop_item!(self, integer, Integer, context);
        let prod_num_built = ProdNum {
            integer: Box::new(integer),
        };
        // Calling user action here
        self.user_grammar.prod_num(&prod_num_built)?;
        self.push(ASTType::ProdNum(prod_num_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// NtName: /"\w+?"/;
    ///
    #[parol_runtime::function_name::named]
    fn nt_name(&mut self, nt_name: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let nt_name = nt_name.token()?.clone();
        let nt_name_built = NtName { nt_name };
        // Calling user action here
        self.user_grammar.nt_name(&nt_name_built)?;
        self.push(ASTType::NtName(nt_name_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Integer: /-?\d+/;
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Dash: '-';
    ///
    #[parol_runtime::function_name::named]
    fn dash(&mut self, dash: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dash = dash.token()?.clone();
        let dash_built = Dash { dash };
        // Calling user action here
        self.user_grammar.dash(&dash_built)?;
        self.push(ASTType::Dash(dash_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// CommaOpt: CommaOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt(&mut self, _comma_opt0: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_opt0 = pop_item!(self, comma_opt0, CommaOpt0, context);
        let comma_opt_built = CommaOpt { comma_opt0 };
        // Calling user action here
        self.user_grammar.comma_opt(&comma_opt_built)?;
        self.push(ASTType::CommaOpt(comma_opt_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// CommaOpt0 /* `Option<T>::Some` */: ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_opt0_0_built = CommaOpt0 {
        // Ignore clipped member 'comma'
        };
        self.push(
            ASTType::CommaOpt0(Some(Box::new(comma_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// CommaOpt0 /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comma_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommaOpt0(None), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for LaDfa2DotGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item LaDfa2DotGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.la_dfa2_dot(&children[0], &children[1], &children[2]),
            1 => self.parts(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            2 => self.comment_start(&children[0], &children[1]),
            3 => self.comment_end(&children[0], &children[1]),
            4 => self.naming_comment(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            5 => self.prod0(&children[0], &children[1], &children[2], &children[3]),
            6 => self.transitions_prefix(&children[0], &children[1], &children[2], &children[3]),
            7 => self.transitions_postfix(&children[0], &children[1]),
            8 => self.transitions(&children[0], &children[1], &children[2]),
            9 => self.trans_list(&children[0]),
            10 => self.trans_list_list_0(&children[0], &children[1]),
            11 => self.trans_list_list_1(),
            12 => self.trans_entry_prefix(&children[0], &children[1]),
            13 => self.trans_entry_postfix(&children[0], &children[1]),
            14 => self.trans_entry_value(&children[0], &children[1]),
            15 => self.trans_entry(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            16 => self.k(&children[0], &children[1], &children[2], &children[3]),
            17 => self.prod_num(&children[0]),
            18 => self.nt_name(&children[0]),
            19 => self.integer(&children[0]),
            20 => self.dash(&children[0]),
            21 => self.comma_opt(&children[0]),
            22 => self.comma_opt0_0(&children[0]),
            23 => self.comma_opt0_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
}
