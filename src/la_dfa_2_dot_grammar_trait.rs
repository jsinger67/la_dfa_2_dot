// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait LaDfa2DotGrammarTrait<'t> {
    /// Semantic action for non-terminal 'LaDfa2Dot'
    fn la_dfa2_dot(&mut self, _arg: &LaDfa2Dot<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parts'
    fn parts(&mut self, _arg: &Parts<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Prod0'
    fn prod0(&mut self, _arg: &Prod0<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Transitions'
    fn transitions(&mut self, _arg: &Transitions<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransList'
    fn trans_list(&mut self, _arg: &TransList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TransEntry'
    fn trans_entry(&mut self, _arg: &TransEntry<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'K'
    fn k(&mut self, _arg: &K<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Integer'
    fn integer(&mut self, _arg: &Integer<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Integer
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Integer<'t> {
    pub integer: Token<'t>, /* -?\d+ */
}

///
/// Type derived for non-terminal K
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct K<'t> {
    pub k: Token<'t>,     /* k */
    pub colon: Token<'t>, /* : */
    pub integer: Box<Integer<'t>>,
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal LaDfa2Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LaDfa2Dot<'t> {
    pub parts: Box<Parts<'t>>,
}

///
/// Type derived for non-terminal Parts
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parts<'t> {
    pub l_brace: Token<'t>, /* { */
    pub prod0: Box<Prod0<'t>>,
    pub transitions: Box<Transitions<'t>>,
    pub k: Box<K<'t>>,
    pub parts_opt: Option<Box<PartsOpt>>,
}

///
/// Type derived for non-terminal PartsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PartsOpt {}

///
/// Type derived for non-terminal Prod0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Prod0<'t> {
    pub prod0: Token<'t>, /* prod0 */
    pub colon: Token<'t>, /* : */
    pub integer: Box<Integer<'t>>,
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal TransEntry
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransEntry<'t> {
    pub trans: Token<'t>,   /* Trans */
    pub l_paren: Token<'t>, /* ( */
    pub integer: Box<Integer<'t>>,
    pub comma: Token<'t>, /* , */
    pub integer0: Box<Integer<'t>>,
    pub comma0: Token<'t>, /* , */
    pub integer1: Box<Integer<'t>>,
    pub comma1: Token<'t>, /* , */
    pub integer2: Box<Integer<'t>>,
    pub r_paren: Token<'t>, /* ) */
    pub comma2: Token<'t>,  /* , */
}

///
/// Type derived for non-terminal TransList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransList<'t> {
    pub trans_list_list: Vec<TransListList<'t>>,
}

///
/// Type derived for non-terminal TransListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransListList<'t> {
    pub trans_entry: Box<TransEntry<'t>>,
}

///
/// Type derived for non-terminal Transitions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Transitions<'t> {
    pub transitions: Token<'t>, /* transitions */
    pub colon: Token<'t>,       /* : */
    pub amp: Token<'t>,         /* & */
    pub l_bracket: Token<'t>,   /* [ */
    pub trans_list: Box<TransList<'t>>,
    pub r_bracket: Token<'t>, /* ] */
    pub transitions_opt: Option<Box<TransitionsOpt>>,
}

///
/// Type derived for non-terminal TransitionsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TransitionsOpt {}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    Integer(Integer<'t>),
    K(K<'t>),
    LaDfa2Dot(LaDfa2Dot<'t>),
    Parts(Parts<'t>),
    PartsOpt(Option<Box<PartsOpt>>),
    Prod0(Prod0<'t>),
    TransEntry(TransEntry<'t>),
    TransList(TransList<'t>),
    TransListList(Vec<TransListList<'t>>),
    Transitions(Transitions<'t>),
    TransitionsOpt(Option<Box<TransitionsOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct LaDfa2DotGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `LaDfa2DotGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> LaDfa2DotGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn LaDfa2DotGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// LaDfa2Dot: 'LookaheadDFA'^ /* Clipped */ Parts;
    ///
    #[parol_runtime::function_name::named]
    fn la_dfa2_dot(
        &mut self,
        _lookahead_d_f_a: &ParseTreeType<'t>,
        _parts: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts = pop_item!(self, parts, Parts, context);
        let la_dfa2_dot_built = LaDfa2Dot {
            // Ignore clipped member 'lookahead_d_f_a'
            parts: Box::new(parts),
        };
        // Calling user action here
        self.user_grammar.la_dfa2_dot(&la_dfa2_dot_built)?;
        self.push(ASTType::LaDfa2Dot(la_dfa2_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Parts: '{' Prod0 Transitions K '}'^ /* Clipped */ PartsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn parts(
        &mut self,
        l_brace: &ParseTreeType<'t>,
        _prod0: &ParseTreeType<'t>,
        _transitions: &ParseTreeType<'t>,
        _k: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _parts_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token()?.clone();
        let parts_opt = pop_item!(self, parts_opt, PartsOpt, context);
        let k = pop_item!(self, k, K, context);
        let transitions = pop_item!(self, transitions, Transitions, context);
        let prod0 = pop_item!(self, prod0, Prod0, context);
        let parts_built = Parts {
            l_brace,
            prod0: Box::new(prod0),
            transitions: Box::new(transitions),
            k: Box::new(k),
            // Ignore clipped member 'r_brace'
            parts_opt,
        };
        // Calling user action here
        self.user_grammar.parts(&parts_built)?;
        self.push(ASTType::Parts(parts_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// PartsOpt /* `Option<T>::Some` */: ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn parts_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parts_opt_0_built = PartsOpt {
        // Ignore clipped member 'comma'
        };
        self.push(
            ASTType::PartsOpt(Some(Box::new(parts_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// PartsOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn parts_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PartsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Prod0: 'prod0' ':' Integer ',';
    ///
    #[parol_runtime::function_name::named]
    fn prod0(
        &mut self,
        prod0: &ParseTreeType<'t>,
        colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let prod0 = prod0.token()?.clone();
        let colon = colon.token()?.clone();
        let comma = comma.token()?.clone();
        let integer = pop_item!(self, integer, Integer, context);
        let prod0_built = Prod0 {
            prod0,
            colon,
            integer: Box::new(integer),
            comma,
        };
        // Calling user action here
        self.user_grammar.prod0(&prod0_built)?;
        self.push(ASTType::Prod0(prod0_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Transitions: 'transitions' ':' '&' '[' TransList ']' TransitionsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions(
        &mut self,
        transitions: &ParseTreeType<'t>,
        colon: &ParseTreeType<'t>,
        amp: &ParseTreeType<'t>,
        l_bracket: &ParseTreeType<'t>,
        _trans_list: &ParseTreeType<'t>,
        r_bracket: &ParseTreeType<'t>,
        _transitions_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let transitions = transitions.token()?.clone();
        let colon = colon.token()?.clone();
        let amp = amp.token()?.clone();
        let l_bracket = l_bracket.token()?.clone();
        let r_bracket = r_bracket.token()?.clone();
        let transitions_opt = pop_item!(self, transitions_opt, TransitionsOpt, context);
        let trans_list = pop_item!(self, trans_list, TransList, context);
        let transitions_built = Transitions {
            transitions,
            colon,
            amp,
            l_bracket,
            trans_list: Box::new(trans_list),
            r_bracket,
            transitions_opt,
        };
        // Calling user action here
        self.user_grammar.transitions(&transitions_built)?;
        self.push(ASTType::Transitions(transitions_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// TransitionsOpt /* `Option<T>::Some` */: ','^ /* Clipped */;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let transitions_opt_0_built = TransitionsOpt {
        // Ignore clipped member 'comma'
        };
        self.push(
            ASTType::TransitionsOpt(Some(Box::new(transitions_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// TransitionsOpt /* `Option<T>::None` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn transitions_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::TransitionsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// TransList: TransListList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list(&mut self, _trans_list_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list = pop_and_reverse_item!(self, trans_list_list, TransListList, context);
        let trans_list_built = TransList { trans_list_list };
        // Calling user action here
        self.user_grammar.trans_list(&trans_list_built)?;
        self.push(ASTType::TransList(trans_list_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// TransListList /* `Vec<T>::Push` */: TransEntry TransListList;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_0(
        &mut self,
        _trans_entry: &ParseTreeType<'t>,
        _trans_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut trans_list_list = pop_item!(self, trans_list_list, TransListList, context);
        let trans_entry = pop_item!(self, trans_entry, TransEntry, context);
        let trans_list_list_0_built = TransListList {
            trans_entry: Box::new(trans_entry),
        };
        // Add an element to the vector
        trans_list_list.push(trans_list_list_0_built);
        self.push(ASTType::TransListList(trans_list_list), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// TransListList /* `Vec<T>::New` */: ;
    ///
    #[parol_runtime::function_name::named]
    fn trans_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans_list_list_1_built = Vec::new();
        self.push(ASTType::TransListList(trans_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// TransEntry: 'Trans' '(' Integer ',' Integer ',' Integer ',' Integer ')' ',';
    ///
    #[parol_runtime::function_name::named]
    fn trans_entry(
        &mut self,
        trans: &ParseTreeType<'t>,
        l_paren: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        comma: &ParseTreeType<'t>,
        _integer0: &ParseTreeType<'t>,
        comma0: &ParseTreeType<'t>,
        _integer1: &ParseTreeType<'t>,
        comma1: &ParseTreeType<'t>,
        _integer2: &ParseTreeType<'t>,
        r_paren: &ParseTreeType<'t>,
        comma2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let trans = trans.token()?.clone();
        let l_paren = l_paren.token()?.clone();
        let comma = comma.token()?.clone();
        let comma0 = comma0.token()?.clone();
        let comma1 = comma1.token()?.clone();
        let r_paren = r_paren.token()?.clone();
        let comma2 = comma2.token()?.clone();
        let integer2 = pop_item!(self, integer2, Integer, context);
        let integer1 = pop_item!(self, integer1, Integer, context);
        let integer0 = pop_item!(self, integer0, Integer, context);
        let integer = pop_item!(self, integer, Integer, context);
        let trans_entry_built = TransEntry {
            trans,
            l_paren,
            integer: Box::new(integer),
            comma,
            integer0: Box::new(integer0),
            comma0,
            integer1: Box::new(integer1),
            comma1,
            integer2: Box::new(integer2),
            r_paren,
            comma2,
        };
        // Calling user action here
        self.user_grammar.trans_entry(&trans_entry_built)?;
        self.push(ASTType::TransEntry(trans_entry_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// K: 'k' ':' Integer ',';
    ///
    #[parol_runtime::function_name::named]
    fn k(
        &mut self,
        k: &ParseTreeType<'t>,
        colon: &ParseTreeType<'t>,
        _integer: &ParseTreeType<'t>,
        comma: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let k = k.token()?.clone();
        let colon = colon.token()?.clone();
        let comma = comma.token()?.clone();
        let integer = pop_item!(self, integer, Integer, context);
        let k_built = K {
            k,
            colon,
            integer: Box::new(integer),
            comma,
        };
        // Calling user action here
        self.user_grammar.k(&k_built)?;
        self.push(ASTType::K(k_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Integer: /-?\d+/;
    ///
    #[parol_runtime::function_name::named]
    fn integer(&mut self, integer: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integer = integer.token()?.clone();
        let integer_built = Integer { integer };
        // Calling user action here
        self.user_grammar.integer(&integer_built)?;
        self.push(ASTType::Integer(integer_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for LaDfa2DotGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item LaDfa2DotGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.la_dfa2_dot(&children[0], &children[1]),
            1 => self.parts(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            2 => self.parts_opt_0(&children[0]),
            3 => self.parts_opt_1(),
            4 => self.prod0(&children[0], &children[1], &children[2], &children[3]),
            5 => self.transitions(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            6 => self.transitions_opt_0(&children[0]),
            7 => self.transitions_opt_1(),
            8 => self.trans_list(&children[0]),
            9 => self.trans_list_list_0(&children[0], &children[1]),
            10 => self.trans_list_list_1(),
            11 => self.trans_entry(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
            ),
            12 => self.k(&children[0], &children[1], &children[2], &children[3]),
            13 => self.integer(&children[0]),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
}
